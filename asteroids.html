<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Asteroids</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #000; color: #fff; font-family: 'Courier New', monospace; display: flex; flex-direction: column; align-items: center; height: 100vh; overflow: hidden; }
#hud { padding: 10px; font-size: 14px; letter-spacing: 2px; }
#hud span { color: #0ff; }
canvas { border: 1px solid #333; }
#msg { position: absolute; text-align: center; }
#msg h1 { color: #0ff; text-shadow: 0 0 20px #0ff; }
#msg p { color: #888; }
#musicBtn { position: fixed; bottom: 10px; right: 10px; background: #001010; border: 1px solid #0ff; color: #0ff; padding: 6px 12px; border-radius: 20px; cursor: pointer; }
</style>
</head>
<body>
<div id="hud">SCORE: <span id="scoreEl">0</span> LIVES: <span id="livesEl">3</span></div>
<canvas id="c"></canvas>
<div id="msg"></div>
<button id="musicBtn">ðŸŽµ Music</button>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
canvas.width = 800; canvas.height = 600;

let score = 0, lives = 3, state = 'start';
let ship, asteroids, bullets, particles, keys = {};

function resetShip() {
  ship = { x: 400, y: 300, vx: 0, vy: 0, angle: 0, size: 12, dead: false };
}
function reset() {
  resetShip(); asteroids = []; bullets = []; particles = [];
  for (let i = 0; i < 8; i++) spawnAsteroid();
}
function spawnAsteroid(x, y, size) {
  const angle = Math.random() * Math.PI * 2;
  const speed = 0.5 + Math.random() * 1.5;
  asteroids.push({
    x: x || Math.random() * 800, y: y || Math.random() * 600,
    vx: Math.cos(angle) * speed, vy: Math.sin(angle) * speed,
    size: size || 30 + Math.random() * 20, vertices: 8 + Math.floor(Math.random() * 6),
    angles: Array.from({ length: 10 }, () => Math.random() * 0.3)
  });
}

function update() {
  if (state !== 'playing') return;
  // Ship
  if (keys['ArrowLeft']) ship.angle -= 0.08;
  if (keys['ArrowRight']) ship.angle += 0.08;
  if (keys['ArrowUp']) {
    ship.vx += Math.cos(ship.angle) * 0.15;
    ship.vy += Math.sin(ship.angle) * 0.15;
    // Thrust particles
    for (let i = 0; i < 2; i++) {
      particles.push({
        x: ship.x - Math.cos(ship.angle) * ship.size, y: ship.y - Math.sin(ship.angle) * ship.size,
        vx: (Math.random() - 0.5) * 2, vy: (Math.random() - 0.5) * 2, life: 0.5, color: '#0ff'
      });
    }
  }
  ship.vx *= 0.99; ship.vy *= 0.99;
  ship.x = (ship.x + ship.vx + 800) % 800;
  ship.y = (ship.y + ship.vy + 600) % 600;
  // Shoot
  if (keys[' '] && !ship.dead) {
    if (!ship.lastShot || Date.now() - ship.lastShot > 200) {
      bullets.push({ x: ship.x + Math.cos(ship.angle) * ship.size, y: ship.y + Math.sin(ship.angle) * ship.size, vx: Math.cos(ship.angle) * 7, vy: Math.sin(ship.angle) * 7, life: 40 });
      ship.lastShot = Date.now();
      playShoot();
    }
  }
  // Bullets
  bullets.forEach(b => { b.x += b.vx; b.y += b.vy; b.life--; });
  bullets = bullets.filter(b => b.life > 0);
  // Asteroids
  asteroids.forEach(a => {
    a.x = (a.x + a.vx + 800) % 800;
    a.y = (a.y + a.vy + 600) % 600;
    // Hit by bullet
    bullets.forEach(b => {
      if (Math.hypot(b.x - a.x, b.y - a.y) < a.size) {
        b.life = 0;
        if (a.size > 15) {
          spawnAsteroid(a.x, a.y, a.size / 2);
          spawnAsteroid(a.x, a.y, a.size / 2);
        }
        a.dead = true;
        score += Math.floor(100 / a.size);
        document.getElementById('scoreEl').textContent = score;
        burst(a.x, a.y, '#fff');
        playExplode();
      }
    });
    // Hit ship
    if (!ship.dead && Math.hypot(a.x - ship.x, a.y - ship.y) < a.size + ship.size) {
      burst(ship.x, ship.y, '#0ff');
      playExplode();
      lives--; document.getElementById('livesEl').textContent = lives;
      ship.dead = true;
      if (lives <= 0) { state = 'gameover'; }
      else { setTimeout(() => { resetShip(); }, 1000); }
    }
  });
  asteroids = asteroids.filter(a => !a.dead);
  if (asteroids.length < 3) for (let i = 0; i < 4; i++) spawnAsteroid();
  // Particles
  particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life -= 0.02; });
  particles = particles.filter(p => p.life > 0);
}

function burst(x, y, color) {
  for (let i = 0; i < 12; i++) {
    const a = (i / 12) * Math.PI * 2;
    particles.push({ x, y, vx: Math.cos(a) * 3, vy: Math.sin(a) * 3, life: 1, color });
  }
}

function draw() {
  ctx.fillStyle = '#000'; ctx.fillRect(0, 0, 800, 600);
  // Draw asteroids (vector style)
  ctx.strokeStyle = '#fff'; ctx.lineWidth = 1;
  asteroids.forEach(a => {
    ctx.beginPath();
    for (let i = 0; i < a.vertices; i++) {
      const ang = (i / a.vertices) * Math.PI * 2 + a.angles[i];
      const r = a.size * (0.9 + Math.sin(Date.now() * 0.001 + i) * 0.1);
      const px = a.x + Math.cos(ang) * r, py = a.y + Math.sin(ang) * r;
      if (i === 0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.closePath(); ctx.stroke();
  });
  // Draw ship
  if (!ship.dead) {
    ctx.strokeStyle = '#0ff'; ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(ship.x + Math.cos(ship.angle) * ship.size, ship.y + Math.sin(ship.angle) * ship.size);
    ctx.lineTo(ship.x + Math.cos(ship.angle + 2.5) * ship.size, ship.y + Math.sin(ship.angle + 2.5) * ship.size);
    ctx.lineTo(ship.x + Math.cos(ship.angle - 2.5) * ship.size, ship.y + Math.sin(ship.angle - 2.5) * ship.size);
    ctx.closePath(); ctx.stroke();
  }
  // Bullets
  ctx.fillStyle = '#0ff';
  bullets.forEach(b => ctx.fillRect(b.x - 1, b.y - 1, 2, 2));
  // Particles
  particles.forEach(p => {
    ctx.globalAlpha = p.life;
    ctx.fillStyle = p.color;
    ctx.fillRect(p.x - 1, p.y - 1, 2, 2);
  });
  ctx.globalAlpha = 1;
  // Messages
  const msg = document.getElementById('msg');
  if (state === 'start') {
    msg.innerHTML = '<h1>ASTEROIDS</h1><p>Arrows: rotate/thrust Â· Space: shoot</p><p>Press any key</p>'; msg.style.display = 'block';
  } else if (state === 'gameover') {
    msg.innerHTML = `<h1>GAME OVER</h1><p>Score: ${score}</p><p>Press R to restart</p>`; msg.style.display = 'block';
  } else msg.style.display = 'none';
}

document.addEventListener('keydown', e => {
  keys[e.key] = true;
  if (state === 'start') { state = 'playing'; }
  if (state === 'gameover' && (e.key === 'r' || e.key === 'R')) { score = 0; lives = 3; reset(); state = 'playing'; document.getElementById('scoreEl').textContent = 0; document.getElementById('livesEl').textContent = 3; }
  if (e.key === 'm' || e.key === 'M') document.getElementById('musicBtn').click();
});
document.addEventListener('keyup', e => keys[e.key] = false);

// Audio
let audioCtx = null, musicOn = false, musicNodes = [];
function initA() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
function playShoot() {
  initA();
  const o = audioCtx.createOscillator(), g = audioCtx.createGain();
  o.type = 'square'; o.frequency.value = 880; o.frequency.exponentialRampToValueAtTime(220, audioCtx.currentTime + 0.1);
  g.gain.value = 0.05; g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
  o.connect(g); g.connect(audioCtx.destination); o.start(); o.stop(audioCtx.currentTime + 0.1);
}
function playExplode() {
  initA();
  const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.2, audioCtx.sampleRate);
  const d = buf.getChannelData(0); for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / d.length * 3);
  const s = audioCtx.createBufferSource(), g = audioCtx.createGain();
  s.buffer = buf; g.gain.value = 0.2; s.connect(g); g.connect(audioCtx.destination); s.start();
}
function startMusic() {
  initA(); stopMusic();
  const m = audioCtx.createGain(); m.gain.value = 0.1; m.connect(audioCtx.destination);
  musicNodes.push(m);
  const bassLine = () => {
    if (!musicOn) return;
    const notes = [55, 0, 65.4, 0, 55, 73.4, 55, 0];
    const t = audioCtx.currentTime;
    for (let i = 0; i < 8; i++) {
      if (notes[i]) {
        const o = audioCtx.createOscillator(), g = audioCtx.createGain();
        o.type = 'sawtooth'; o.frequency.value = notes[i];
        g.gain.setValueAtTime(0, t + i * 0.25); g.gain.linearRampToValueAtTime(0.06, t + i * 0.25 + 0.02);
        g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.25 + 0.2);
        o.connect(g); g.connect(m); o.start(t + i * 0.25); o.stop(t + i * 0.25 + 0.25);
      }
    }
    setTimeout(bassLine, 2000);
  };
  bassLine();
}
function stopMusic() { musicNodes.forEach(n => { try { n.stop?.(); n.disconnect?.(); } catch (e) { } }); musicNodes = []; }
document.getElementById('musicBtn').addEventListener('click', () => { musicOn = !musicOn; document.getElementById('musicBtn').textContent = musicOn ? 'ðŸŽµ Music ON' : 'ðŸŽµ Music'; if (musicOn) startMusic(); else stopMusic(); });

reset();
function loop() { update(); draw(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>
