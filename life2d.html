<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Life 2D - Artificial Life Simulator</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;400;500;600;700;800&family=Orbitron:wght@400;500;600;700;800;900&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --neon-blue: #00f5ff;
            --neon-pink: #ff00ff;
            --neon-green: #00ff88;
            --neon-purple: #b829dd;
            --neon-orange: #ff6b35;
            --neon-yellow: #ffff00;
            --neon-red: #ff3333;
            --neon-cyan: #00ffff;
            --dark-bg: #050508;
            --panel-bg: rgba(5, 5, 8, 0.95);
            --panel-border: rgba(0, 245, 255, 0.3);
        }
        
        body {
            background: var(--dark-bg);
            color: #fff;
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        
        canvas {
            display: block;
        }
        
        .hud {
            position: fixed;
            z-index: 10;
            pointer-events: none;
        }
        
        .hud-top {
            top: 0;
            left: 0;
            right: 0;
            padding: 12px 20px;
            background: linear-gradient(180deg, rgba(0,0,0,0.95) 0%, transparent 100%);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 20px;
            flex-wrap: wrap;
            pointer-events: none;
        }
        
        .hud-top > * {
            pointer-events: auto;
        }
        
        .title-block {
            flex-shrink: 0;
        }
        
        .title-block h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 22px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            background: linear-gradient(90deg, var(--neon-blue), var(--neon-pink), var(--neon-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: titlePulse 3s ease-in-out infinite;
        }
        
        @keyframes titlePulse {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }
        
        .stats-container {
            flex: 1;
            min-width: 200px;
            max-width: 450px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }
        
        .stat-box {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 6px;
            padding: 6px 8px;
            text-align: center;
        }
        
        .stat-box .value {
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            font-weight: 700;
        }
        
        .stat-box .label {
            font-size: 8px;
            color: #888;
            text-transform: uppercase;
        }
        
        .hud-left {
            top: 80px;
            left: 15px;
            width: 280px;
            max-height: calc(100vh - 150px);
            overflow-y: auto;
            pointer-events: auto;
        }
        
        .hud-right {
            top: 80px;
            right: 15px;
            width: 280px;
            max-height: calc(100vh - 150px);
            overflow-y: auto;
            pointer-events: auto;
        }
        
        .hud-bottom {
            bottom: 0;
            left: 0;
            right: 0;
            padding: 12px;
            background: linear-gradient(0deg, rgba(0,0,0,0.95) 0%, transparent 100%);
            display: flex;
            justify-content: center;
            gap: 6px;
            flex-wrap: wrap;
            pointer-events: auto;
            max-height: 90px;
            overflow-y: auto;
        }
        
        .control-panel {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 10px;
            padding: 12px;
            backdrop-filter: blur(10px);
        }
        
        .panel-section {
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .panel-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }
        
        .panel-section h3 {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            color: var(--neon-blue);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }
        
        .btn {
            background: rgba(0,245,255,0.1);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 6px 10px;
            border-radius: 5px;
            font-family: 'Orbitron', sans-serif;
            font-size: 9px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            pointer-events: all;
        }
        
        .btn:hover {
            background: rgba(0,245,255,0.2);
            transform: translateY(-1px);
        }
        
        .btn.active {
            background: var(--neon-green);
            border-color: var(--neon-green);
            color: #000;
        }
        
        .btn.primary {
            background: var(--neon-blue);
            border-color: var(--neon-blue);
            color: #000;
        }
        
        .btn.danger {
            background: rgba(255,51,51,0.2);
            border-color: var(--neon-red);
            color: var(--neon-red);
        }
        
        .btn.pink {
            background: rgba(255,0,255,0.1);
            border-color: var(--neon-pink);
            color: var(--neon-pink);
        }
        
        .btn-row {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
        
        .slider-group {
            margin-bottom: 8px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            color: #aaa;
            margin-bottom: 3px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 3px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: var(--neon-blue);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .species-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 4px;
        }
        
        .species-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 9px;
            padding: 3px 6px;
            background: rgba(255,255,255,0.03);
            border-radius: 4px;
        }
        
        .species-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        
        .chart-container {
            height: 60px;
            background: rgba(0,0,0,0.4);
            border-radius: 5px;
            padding: 6px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        select {
            background: rgba(0,0,0,0.5);
            border: 1px solid var(--panel-border);
            color: #fff;
            padding: 5px 8px;
            border-radius: 5px;
            font-size: 11px;
            width: 100%;
        }
        
        @media (max-width: 1200px) {
            .hud-left, .hud-right { display: none; }
            .hud-top { justify-content: center; }
        }
    </style>
</head>
<body>
    <div style="position: fixed; top: 20px; right: 20px; z-index: 1000; display: flex; gap: 8px; align-items: center;">
        <button id="music-toggle-btn" onclick="ElectroAudio.toggle()" title="Toggle Music [M]"
            style="background: rgba(0,0,0,0.85); border: 1px solid #ff00ff; color: #ff00ff; padding: 8px 14px; border-radius: 4px; font-size: 13px; font-family: 'Rajdhani', sans-serif; cursor: pointer; transition: all 0.3s; letter-spacing: 1px;">
            üéµ MUSIC
        </button>
        <a href="/games" style="background: rgba(0,0,0,0.8); border: 1px solid #00ff88; color: #00ff88; padding: 8px 16px; border-radius: 4px; text-decoration: none; font-size: 14px; font-family: 'Rajdhani', sans-serif; display: inline-block;">üéÆ Games</a>
    </div>

    <!-- Floating birth/death particles overlay -->
    <canvas id="fxCanvas" style="position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:5;"></canvas>
    
    <div id="canvas-container">
        <canvas id="simCanvas"></canvas>
    </div>
    
    <div class="hud hud-top">
        <div class="title-block">
            <h1>‚óâ Particle Life 2D</h1>
            <p style="font-size: 10px; color: #888;">Artificial Life Simulation</p>
        </div>
        
        <div class="stats-container">
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="value" id="particle-count">0</div>
                    <div class="label">Particles</div>
                </div>
                <div class="stat-box">
                    <div class="value" id="generation">0</div>
                    <div class="label">Generation</div>
                </div>
                <div class="stat-box">
                    <div class="value" id="fps">60</div>
                    <div class="label">FPS</div>
                </div>
                <div class="stat-box">
                    <div class="value" id="births">0</div>
                    <div class="label">Births</div>
                </div>
                <div class="stat-box">
                    <div class="value" id="deaths">0</div>
                    <div class="label">Deaths</div>
                </div>
                <div class="stat-box">
                    <div class="value" id="species">0</div>
                    <div class="label">Species</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="hud hud-left">
        <div class="control-panel">
            <div class="panel-section">
                <h3>Simulation Control</h3>
                <div class="btn-row">
                    <button class="btn primary" id="play-btn" onclick="togglePlay()">‚ñ∂ PLAY</button>
                    <button class="btn" onclick="step()">‚è≠ STEP</button>
                    <button class="btn danger" onclick="clearAll()">üóë CLEAR</button>
                </div>
                
                <div class="slider-group" style="margin-top: 10px;">
                    <div class="slider-label">
                        <span>Simulation Speed</span>
                        <span id="speed-display">1x</span>
                    </div>
                    <input type="range" id="speed" min="0" max="5" step="1" value="1" onchange="updateSpeed(this.value)">
                </div>
            </div>
            
            <div class="panel-section">
                <h3>Physics Settings</h3>
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Attraction Radius</span>
                        <span id="radius-display">50</span>
                    </div>
                    <input type="range" id="radius" min="10" max="150" value="50" onchange="updateRadius(this.value)">
                </div>
                
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Force Strength</span>
                        <span id="force-display">0.5</span>
                    </div>
                    <input type="range" id="force" min="0.1" max="2" step="0.1" value="0.5" onchange="updateForce(this.value)">
                </div>
                
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Friction</span>
                        <span id="friction-display">0.9</span>
                    </div>
                    <input type="range" id="friction" min="0.5" max="0.99" step="0.01" value="0.9" onchange="updateFriction(this.value)">
                </div>
            </div>
            
            <div class="panel-section">
                <h3>Species Distribution</h3>
                <div class="species-grid" id="species-grid"></div>
            </div>
        </div>
    </div>
    
    <div class="hud hud-right">
        <div class="control-panel">
            <div class="panel-section">
                <h3>Spawn Species</h3>
                <div class="btn-row">
                    <button class="btn" onclick="spawnBatch('red', 50)">üî¥ Red</button>
                    <button class="btn" onclick="spawnBatch('blue', 50)">üîµ Blue</button>
                    <button class="btn" onclick="spawnBatch('green', 50)">üü¢ Green</button>
                </div>
                <div class="btn-row" style="margin-top: 6px;">
                    <button class="btn" onclick="spawnBatch('yellow', 30)">üü° Yellow</button>
                    <button class="btn" onclick="spawnBatch('purple', 30)">üü£ Purple</button>
                    <button class="btn" onclick="spawnBatch('cyan', 30)">üîµ Cyan</button>
                </div>
            </div>
            
            <div class="panel-section">
                <h3>World Presets</h3>
                <div class="btn-row">
                    <button class="btn" onclick="loadPreset('random')">üé≤ Random</button>
                    <button class="btn" onclick="loadPreset('ecosystem')">üåç Ecosystem</button>
                    <button class="btn" onclick="loadPreset('war')">‚öîÔ∏è War</button>
                </div>
                <div class="btn-row" style="margin-top: 6px;">
                    <button class="btn" onclick="loadPreset('symbiosis')">ü§ù Symbiosis</button>
                    <button class="btn" onclick="loadPreset('predator')">ü¶Å Predator</button>
                    <button class="btn" onclick="loadPreset('cellular')">üî¨ Cellular</button>
                </div>
            </div>
            
            <div class="panel-section">
                <h3>Population Graph</h3>
                <div class="chart-container">
                    <canvas id="graphCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>
    
    <div class="hud hud-bottom">
        <button class="btn" onclick="spawnParticle('red')">üî¥ Red</button>
        <button class="btn" onclick="spawnParticle('blue')">üîµ Blue</button>
        <button class="btn" onclick="spawnParticle('green')">üü¢ Green</button>
        <button class="btn" onclick="spawnParticle('yellow')">üü° Yellow</button>
        <button class="btn" onclick="spawnParticle('purple')">üü£ Purple</button>
        <button class="btn" onclick="spawnParticle('cyan')">üîµ Cyan</button>
        <button class="btn pink" onclick="spawnParticle('predator')">ü¶Å Predator</button>
        <button class="btn" onclick="spawnParticle('prey')">üêá Prey</button>
        <button class="btn danger" onclick="spawnParticle('virus')">ü¶† Virus</button>
        <button class="btn" onclick="spawnParticle('plant')">üå± Plant</button>
    </div>

    <script>
        // ============================================
        // PARTICLE LIFE 2D - Artificial Life Simulator
        // ============================================
        
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const graphCanvas = document.getElementById('graphCanvas');
        const graphCtx = graphCanvas.getContext('2d');
        
        let width, height;
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            if (graphCanvas) {
                graphCanvas.width = graphCanvas.offsetWidth;
                graphCanvas.height = graphCanvas.offsetHeight;
            }
        }
        window.addEventListener('resize', resize);
        resize();
        
        // Configuration
        const CONFIG = {
            particleRadius: 3,
            maxParticles: 1500,
            attractionRadius: 50,
            forceMultiplier: 0.5,
            friction: 0.9,
            speed: 1,
            mutationRate: 0.01
        };
        
        // Species definitions with attraction/repulsion matrix
        const SPECIES = {
            red: { color: '#ff4444', radius: 3, mass: 1 },
            blue: { color: '#4444ff', radius: 3, mass: 1 },
            green: { color: '#44ff44', radius: 3, mass: 1 },
            yellow: { color: '#ffff44', radius: 3, mass: 1 },
            purple: { color: '#ff44ff', radius: 3, mass: 1 },
            cyan: { color: '#44ffff', radius: 3, mass: 1 },
            predator: { color: '#ff0000', radius: 5, mass: 2, glow: true },
            prey: { color: '#00ff00', radius: 2.5, mass: 0.8 },
            virus: { color: '#ff00ff', radius: 2, mass: 0.5, pulse: true },
            plant: { color: '#228b22', radius: 4, mass: 1.5, glow: true }
        };
        
        // Attraction matrix: positive = attract, negative = repel
        const ATTRACTIONS = {
            red: { red: 0.1, blue: -0.2, green: 0.3, yellow: 0, purple: 0.2, cyan: -0.1 },
            blue: { red: -0.2, blue: 0.1, green: 0, yellow: 0.3, purple: -0.1, cyan: 0.2 },
            green: { red: 0.3, blue: 0, green: 0.1, yellow: -0.2, purple: 0, cyan: 0.3 },
            yellow: { red: 0, blue: 0.3, green: -0.2, yellow: 0.1, purple: 0.3, cyan: 0 },
            purple: { red: 0.2, blue: -0.1, green: 0, yellow: 0.3, purple: 0.1, cyan: -0.2 },
            cyan: { red: -0.1, blue: 0.2, green: 0.3, yellow: 0, purple: -0.2, cyan: 0.1 },
            predator: { prey: 1, plant: 0.5, red: 0.2, blue: 0.2, green: 0.2, yellow: 0.2, purple: 0.2, cyan: 0.2 },
            prey: { plant: 0.8, predator: -1, red: -0.3, blue: -0.3, green: 0.3, yellow: 0 },
            virus: { red: 0.5, blue: 0.5, green: 0.5, yellow: 0.5, purple: 0.5, cyan: 0.5, prey: 0.8, plant: 0.3 },
            plant: { red: -0.1, blue: -0.1, green: 0.1, yellow: 0.1, purple: -0.1, cyan: 0.1 }
        };
        
        let particles = [];
        let isPlaying = false;
        let generation = 0;
        let births = 0;
        let deaths = 0;
        let lastTime = 0;
        let fps = 60;
        let history = [];
        
        class Particle {
            constructor(type, x, y) {
                this.type = type;
                this.x = x || Math.random() * width;
                this.y = y || Math.random() * height;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.energy = 50 + Math.random() * 50;
                this.age = 0;
                this.id = Math.random().toString(36).substr(2, 9);
                
                const props = SPECIES[type];
                this.radius = props.radius;
                this.mass = props.mass;
            }
            
            update() {
                // Apply forces from other particles
                for (let other of particles) {
                    if (other === this) continue;
                    
                    const dx = other.x - this.x;
                    const dy = other.y - this.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < CONFIG.attractionRadius && dist > this.radius + other.radius) {
                        let attraction = 0;
                        
                        // Get attraction value
                        if (ATTRACTIONS[this.type] && ATTRACTIONS[this.type][other.type] !== undefined) {
                            attraction = ATTRACTIONS[this.type][other.type];
                        } else if (ATTRACTIONS[other.type] && ATTRACTIONS[other.type][this.type] !== undefined) {
                            attraction = ATTRACTIONS[other.type][this.type];
                        }
                        
                        const force = attraction * CONFIG.forceMultiplier / (dist * 0.1 + 1);
                        
                        this.vx += (dx / dist) * force / this.mass;
                        this.vy += (dy / dist) * force / this.mass;
                    }
                    
                    // Collision
                    if (dist < this.radius + other.radius) {
                        this.handleCollision(other);
                    }
                }
                
                // Apply velocity
                this.x += this.vx * CONFIG.speed;
                this.y += this.vy * CONFIG.speed;
                
                // Friction
                this.vx *= CONFIG.friction;
                this.vy *= CONFIG.friction;
                
                // Boundaries
                if (this.x < this.radius) {
                    this.x = this.radius;
                    this.vx *= -0.8;
                }
                if (this.x > width - this.radius) {
                    this.x = width - this.radius;
                    this.vx *= -0.8;
                }
                if (this.y < this.radius) {
                    this.y = this.radius;
                    this.vy *= -0.8;
                }
                if (this.y > height - this.radius) {
                    this.y = height - this.radius;
                    this.vy *= -0.8;
                }
                
                // Metabolism
                this.energy -= 0.05;
                this.age++;
                
                // Plants get energy from being still
                if (this.type === 'plant' && Math.abs(this.vx) < 0.1 && Math.abs(this.vy) < 0.1) {
                    this.energy += 0.2;
                }
                
                // Reproduce if healthy
                if (this.energy > 100 && Math.random() < 0.001) {
                    this.energy -= 30;
                    return new Particle(this.type, this.x + (Math.random() - 0.5) * 20, 
                                       this.y + (Math.random() - 0.5) * 20);
                }
                
                // Die if no energy
                if (this.energy <= 0) return 'die';
                
                return null;
            }
            
            handleCollision(other) {
                // Predator eats prey
                if (this.type === 'predator' && other.type === 'prey') {
                    this.energy += 40;
                    other.energy = 0;
                }
                
                // Prey eats plants
                if (this.type === 'prey' && other.type === 'plant') {
                    this.energy += 30;
                    other.energy -= 20;
                }
                
                // Virus infects
                if (this.type === 'virus' && !['virus', 'predator'].includes(other.type)) {
                    other.energy -= 10;
                    this.energy += 5;
                    if (Math.random() < 0.1) other.type = 'virus';
                }
                
                // Bounce
                const dx = other.x - this.x;
                const dy = other.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist > 0) {
                    const nx = dx / dist;
                    const ny = dy / dist;
                    
                    const dvx = this.vx - other.vx;
                    const dvy = this.vy - other.vy;
                    
                    const velAlongNormal = dvx * nx + dvy * ny;
                    
                    if (velAlongNormal > 0) return;
                    
                    const e = 0.8;
                    const impulse = -(1 + e) * velAlongNormal / (1/this.mass + 1/other.mass);
                    
                    this.vx -= impulse * nx / this.mass;
                    this.vy -= impulse * ny / this.mass;
                    other.vx += impulse * nx / other.mass;
                    other.vy += impulse * ny / other.mass;
                    
                    // Separate
                    const overlap = (this.radius + other.radius - dist) / 2;
                    this.x -= nx * overlap;
                    this.y -= ny * overlap;
                    other.x += nx * overlap;
                    other.y += ny * overlap;
                }
            }
            
            draw(ctx, time) {
                const props = SPECIES[this.type];
                const energyRatio = Math.min(1, this.energy / 100);

                // Outer ambient glow ‚Äî ALL particles get a halo
                const glowRadius = this.radius * (props.glow ? 5 : 3.5);
                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowRadius);
                const alpha = props.glow ? 'aa' : '55';
                gradient.addColorStop(0, props.color + alpha);
                gradient.addColorStop(0.4, props.color + '22');
                gradient.addColorStop(1, props.color + '00');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.x, this.y, glowRadius, 0, Math.PI * 2);
                ctx.fill();

                // Pulse effect
                let r = this.radius;
                if (props.pulse || this.type === 'virus') {
                    r += Math.sin(time * 0.012 + this.id.charCodeAt(0)) * 1.2;
                }
                // Energy breathing
                r *= 0.7 + energyRatio * 0.3;

                // Main body ‚Äî neon rim effect
                ctx.shadowBlur = 12;
                ctx.shadowColor = props.color;
                ctx.fillStyle = props.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;

                // White inner highlight
                const hG = ctx.createRadialGradient(this.x - r*0.3, this.y - r*0.3, 0, this.x, this.y, r);
                hG.addColorStop(0, `rgba(255,255,255,${energyRatio * 0.6})`);
                hG.addColorStop(1, 'rgba(255,255,255,0)');
                ctx.fillStyle = hG;
                ctx.beginPath();
                ctx.arc(this.x, this.y, r, 0, Math.PI * 2);
                ctx.fill();

                // Neon outline ring
                ctx.strokeStyle = props.color + Math.floor(energyRatio * 255).toString(16).padStart(2,'0');
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(this.x, this.y, r + 1, 0, Math.PI * 2);
                ctx.stroke();

                // Velocity trail line
                const speed = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
                if (speed > 0.2) {
                    ctx.strokeStyle = props.color + '60';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    ctx.lineTo(this.x + this.vx * 6, this.y + this.vy * 6);
                    ctx.stroke();
                }
            }
        }
        
        function spawnParticle(type, x, y) {
            if (particles.length >= CONFIG.maxParticles) return;
            particles.push(new Particle(type, x, y));
        }
        
        function spawnBatch(type, count) {
            for (let i = 0; i < count; i++) {
                spawnParticle(type);
            }
        }
        
        function update() {
            const newParticles = [];
            const toRemove = [];
            
            for (let i = 0; i < particles.length; i++) {
                const result = particles[i].update();
                if (result === 'die') {
                    toRemove.push(i);
                    deaths++;
                } else if (result instanceof Particle) {
                    newParticles.push(result);
                    births++;
                }
            }
            
            // Remove dead
            for (let i = toRemove.length - 1; i >= 0; i--) {
                particles.splice(toRemove[i], 1);
            }
            
            // Add newborns
            particles.push(...newParticles);
            
            generation++;
        }
        
        function draw() {
            // Trail effect ‚Äî slightly stronger for neon ghost trails
            ctx.fillStyle = 'rgba(5, 5, 8, 0.25)';
            ctx.fillRect(0, 0, width, height);

            // Background radial glow for ambiance
            const bgGrad = ctx.createRadialGradient(width/2, height/2, 0, width/2, height/2, Math.max(width, height) * 0.7);
            bgGrad.addColorStop(0, 'rgba(20,0,30,0.04)');
            bgGrad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, width, height);
            
            const time = Date.now();
            
            // Draw attraction connections with neon color
            ctx.strokeStyle = 'rgba(0, 245, 255, 0.06)';
            ctx.lineWidth = 0.8;
            for (let i = 0; i < particles.length; i += 3) {
                for (let j = i + 1; j < particles.length && j < i + 5; j++) {
                    const dx = particles[j].x - particles[i].x;
                    const dy = particles[j].y - particles[i].y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < CONFIG.attractionRadius * 0.5) {
                        ctx.beginPath();
                        ctx.moveTo(particles[i].x, particles[i].y);
                        ctx.lineTo(particles[j].x, particles[j].y);
                        ctx.stroke();
                    }
                }
            }
            
            // Draw particles
            for (let p of particles) {
                p.draw(ctx, time);
            }
        }
        
        function updateStats() {
            document.getElementById('particle-count').textContent = particles.length;
            document.getElementById('generation').textContent = generation;
            document.getElementById('births').textContent = births;
            document.getElementById('deaths').textContent = deaths;
            
            const species = {};
            particles.forEach(p => species[p.type] = (species[p.type] || 0) + 1);
            document.getElementById('species').textContent = Object.keys(species).length;
            
            // Update species grid
            const grid = document.getElementById('species-grid');
            let html = '';
            for (const [type, count] of Object.entries(species)) {
                html += `
                    <div class="species-item">
                        <div class="species-dot" style="background: ${SPECIES[type].color};"></div>
                        <span>${type}: ${count}</span>
                    </div>
                `;
            }
            grid.innerHTML = html;
            
            // Update history for graph
            history.push({
                total: particles.length,
                ...species
            });
            if (history.length > 100) history.shift();
            
            drawGraph();
        }
        
        function drawGraph() {
            const w = graphCanvas.width;
            const h = graphCanvas.height;
            graphCtx.clearRect(0, 0, w, h);
            
            if (history.length < 2) return;
            
            const colors = {
                red: '#ff4444', blue: '#4444ff', green: '#44ff44',
                yellow: '#ffff44', purple: '#ff44ff', cyan: '#44ffff',
                predator: '#ff0000', prey: '#00ff00', virus: '#ff00ff', plant: '#228b22'
            };
            
            // Draw each species line
            for (const type of Object.keys(SPECIES)) {
                graphCtx.strokeStyle = colors[type] || '#fff';
                graphCtx.lineWidth = 1.5;
                graphCtx.beginPath();
                
                const maxVal = Math.max(...history.map(h => h[type] || 0), 10);
                
                history.forEach((h, i) => {
                    const x = (i / (history.length - 1)) * w;
                    const y = h - (h[type] || 0) / maxVal * h;
                    
                    if (i === 0) graphCtx.moveTo(x, y);
                    else graphCtx.lineTo(x, y);
                });
                
                graphCtx.stroke();
            }
        }
        
        function loop(timestamp) {
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            fps = Math.round(1000 / deltaTime);
            document.getElementById('fps').textContent = fps;
            
            if (isPlaying) {
                for (let i = 0; i < CONFIG.speed; i++) {
                    update();
                }
            }
            
            draw();
            
            if (generation % 10 === 0) {
                updateStats();
            }
            
            requestAnimationFrame(loop);
        }
        
        // Controls
        function togglePlay() {
            isPlaying = !isPlaying;
            document.getElementById('play-btn').textContent = isPlaying ? '‚è∏ PAUSE' : '‚ñ∂ PLAY';
            document.getElementById('play-btn').classList.toggle('active', isPlaying);
        }
        
        function step() {
            update();
            draw();
            updateStats();
        }
        
        function clearAll() {
            particles = [];
            generation = 0;
            births = 0;
            deaths = 0;
            history = [];
            ctx.clearRect(0, 0, width, height);
            updateStats();
        }
        
        function updateSpeed(val) {
            CONFIG.speed = parseInt(val);
            document.getElementById('speed-display').textContent = val + 'x';
        }
        
        function updateRadius(val) {
            CONFIG.attractionRadius = parseInt(val);
            document.getElementById('radius-display').textContent = val;
        }
        
        function updateForce(val) {
            CONFIG.forceMultiplier = parseFloat(val);
            document.getElementById('force-display').textContent = val;
        }
        
        function updateFriction(val) {
            CONFIG.friction = parseFloat(val);
            document.getElementById('friction-display').textContent = val;
        }
        
        function loadPreset(name) {
            clearAll();
            
            switch(name) {
                case 'random':
                    spawnBatch('red', 100);
                    spawnBatch('blue', 100);
                    spawnBatch('green', 100);
                    break;
                    
                case 'ecosystem':
                    spawnBatch('plant', 50);
                    spawnBatch('prey', 100);
                    spawnBatch('predator', 20);
                    break;
                    
                case 'war':
                    spawnBatch('red', 150);
                    spawnBatch('blue', 150);
                    break;
                    
                case 'symbiosis':
                    spawnBatch('green', 80);
                    spawnBatch('yellow', 80);
                    spawnBatch('cyan', 80);
                    break;
                    
                case 'predator':
                    spawnBatch('prey', 200);
                    spawnBatch('predator', 50);
                    spawnBatch('plant', 30);
                    break;
                    
                case 'cellular':
                    spawnBatch('red', 50);
                    spawnBatch('blue', 50);
                    spawnBatch('green', 50);
                    spawnBatch('yellow', 50);
                    spawnBatch('purple', 50);
                    spawnBatch('cyan', 50);
                    break;
            }
            
            updateStats();
        }
        
        // Mouse interaction
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            spawnParticle('red', x, y);
            updateStats();
        });
        
        // Start
        loadPreset('cellular');
        requestAnimationFrame(loop);

        // ============================================
        // ELECTRONIC AMBIENT MUSIC SYSTEM
        // ============================================
        const ElectroAudio = {
            ctx: null, masterGain: null, musicGain: null, sfxGain: null,
            isPlaying: false, isMuted: false, volume: 0.18,
            oscillators: [], intervals: [], noteIdx: 0,
            // C minor pentatonic ‚Äî perfect for synthetic/electronic feel
            scale: [130.81, 155.56, 174.61, 195.99, 233.08, 261.63, 311.13, 349.23, 392.00],

            init() {
                if (this.ctx) return;
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                // Master chain: compressor ‚Üí master gain ‚Üí output
                const comp = this.ctx.createDynamicsCompressor();
                comp.threshold.value = -18; comp.ratio.value = 4;
                comp.attack.value = 0.003; comp.release.value = 0.25;
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = this.volume;
                this.musicGain = this.ctx.createGain();
                this.musicGain.gain.value = 0.75;
                this.sfxGain = this.ctx.createGain();
                this.sfxGain.gain.value = 1;
                this.musicGain.connect(comp); this.sfxGain.connect(comp);
                comp.connect(this.masterGain);
                this.masterGain.connect(this.ctx.destination);
            },

            resume() { if (this.ctx?.state === 'suspended') this.ctx.resume(); },

            createDrone(freq, gainVal, filterFreq = 500) {
                const osc = this.ctx.createOscillator();
                const g = this.ctx.createGain();
                const filt = this.ctx.createBiquadFilter();
                // LFO for filter wobble
                const lfo = this.ctx.createOscillator();
                const lfoG = this.ctx.createGain();
                lfo.frequency.value = 0.08 + Math.random() * 0.05;
                lfoG.gain.value = filterFreq * 0.4;
                lfo.connect(lfoG); lfoG.connect(filt.frequency);
                lfo.start();
                osc.type = 'sawtooth'; osc.frequency.value = freq;
                filt.type = 'lowpass'; filt.frequency.value = filterFreq; filt.Q.value = 3;
                g.gain.value = 0;
                g.gain.linearRampToValueAtTime(gainVal, this.ctx.currentTime + 3);
                osc.connect(filt); filt.connect(g); g.connect(this.musicGain);
                osc.start();
                this.oscillators.push(osc, lfo);
            },

            createPad(freqs, gainVal) {
                freqs.forEach(freq => {
                    const osc = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    osc.type = 'sine'; osc.frequency.value = freq;
                    g.gain.value = 0;
                    g.gain.linearRampToValueAtTime(gainVal, this.ctx.currentTime + 4);
                    osc.connect(g); g.connect(this.musicGain);
                    osc.start();
                    this.oscillators.push(osc);
                });
            },

            startArpeggio() {
                // Fast electronic arp at 16th notes (150 BPM ‚Üí 100ms)
                const id = setInterval(() => {
                    if (!this.isPlaying || this.isMuted) return;
                    const freq = this.scale[this.noteIdx % this.scale.length] * 4;
                    const osc = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    const filt = this.ctx.createBiquadFilter();
                    osc.type = 'square'; osc.frequency.value = freq;
                    filt.type = 'bandpass'; filt.frequency.value = freq; filt.Q.value = 8;
                    g.gain.setValueAtTime(0.025, this.ctx.currentTime);
                    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.12);
                    osc.connect(filt); filt.connect(g); g.connect(this.musicGain);
                    osc.start(); osc.stop(this.ctx.currentTime + 0.15);
                    this.noteIdx++;
                    if (Math.random() < 0.15) this.noteIdx += 2; // Skip notes for variation
                }, 100);
                this.intervals.push(id);
            },

            startBeat() {
                // 120 BPM kick/snare
                let beat = 0;
                const id = setInterval(() => {
                    if (!this.isPlaying || this.isMuted) return;
                    if (beat % 4 === 0 || beat % 4 === 2) this._kick();
                    if (beat % 4 === 1 || beat % 4 === 3) this._snare();
                    if (beat % 2 !== 0) this._hihat();
                    beat++;
                }, 125); // 120 BPM / 2 = 8th notes
                this.intervals.push(id);
            },

            _kick() {
                const osc = this.ctx.createOscillator(), g = this.ctx.createGain(), now = this.ctx.currentTime;
                osc.frequency.setValueAtTime(160, now); osc.frequency.exponentialRampToValueAtTime(25, now + 0.15);
                g.gain.setValueAtTime(0.6, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
                osc.connect(g); g.connect(this.musicGain); osc.start(now); osc.stop(now + 0.16);
            },
            _snare() {
                const n = this.ctx.sampleRate * 0.06;
                const buf = this.ctx.createBuffer(1, n, this.ctx.sampleRate);
                const d = buf.getChannelData(0); for (let i = 0; i < n; i++) d[i] = Math.random() * 2 - 1;
                const src = this.ctx.createBufferSource(), filt = this.ctx.createBiquadFilter(), g = this.ctx.createGain(), now = this.ctx.currentTime;
                filt.type = 'highpass'; filt.frequency.value = 2000;
                g.gain.setValueAtTime(0.18, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.06);
                src.buffer = buf; src.connect(filt); filt.connect(g); g.connect(this.musicGain); src.start();
            },
            _hihat() {
                const n = this.ctx.sampleRate * 0.025;
                const buf = this.ctx.createBuffer(1, n, this.ctx.sampleRate);
                const d = buf.getChannelData(0); for (let i = 0; i < n; i++) d[i] = Math.random() * 2 - 1;
                const src = this.ctx.createBufferSource(), filt = this.ctx.createBiquadFilter(), g = this.ctx.createGain(), now = this.ctx.currentTime;
                filt.type = 'highpass'; filt.frequency.value = 9000;
                g.gain.setValueAtTime(0.05, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.025);
                src.buffer = buf; src.connect(filt); filt.connect(g); g.connect(this.musicGain); src.start();
            },

            startMusic() {
                this.init(); this.resume(); this.isPlaying = true;
                this.createDrone(65.41, 0.07, 400);   // C2 bass drone
                this.createDrone(97.99, 0.04, 600);    // G2
                this.createDrone(130.81, 0.03, 800);   // C3
                this.createPad([261.63, 311.13, 392.0], 0.025); // Cm chord pad
                this.startArpeggio();
                this.startBeat();
                this.updateUI();
            },

            stopMusic() {
                this.isPlaying = false;
                this.oscillators.forEach(o => { try { o.stop(); } catch(e) {} });
                this.oscillators = [];
                this.intervals.forEach(clearInterval); this.intervals = [];
                this.updateUI();
            },

            toggle() {
                if (!this.isPlaying) { this.startMusic(); return; }
                this.isMuted = !this.isMuted;
                if (this.masterGain) this.masterGain.gain.setTargetAtTime(this.isMuted ? 0 : this.volume, this.ctx.currentTime, 0.3);
                this.updateUI();
            },

            setVolume(v) {
                this.volume = v;
                if (this.masterGain && !this.isMuted) this.masterGain.gain.setTargetAtTime(v, this.ctx.currentTime, 0.1);
            },

            updateUI() {
                const btn = document.getElementById('music-toggle-btn');
                if (!btn) return;
                if (!this.isPlaying) { btn.textContent = 'üéµ MUSIC'; btn.style.borderColor = '#444'; btn.style.color = '#888'; btn.style.animation = ''; }
                else if (this.isMuted) { btn.textContent = 'üîá MUTED'; btn.style.borderColor = '#555'; btn.style.color = '#888'; btn.style.animation = ''; }
                else { btn.textContent = 'üîä LIVE'; btn.style.borderColor = '#ff00ff'; btn.style.color = '#ff00ff'; btn.style.animation = 'musicPulse2d 2s ease-in-out infinite'; }
            },

            // ---- Sound Effects ----
            playBirth() {
                if (!this.ctx || !this.isPlaying || this.isMuted) return;
                const freq = 600 + Math.random() * 800;
                const osc = this.ctx.createOscillator(), g = this.ctx.createGain(), now = this.ctx.currentTime;
                osc.type = 'sine'; osc.frequency.setValueAtTime(freq, now); osc.frequency.linearRampToValueAtTime(freq * 1.6, now + 0.06);
                g.gain.setValueAtTime(0.04, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
                osc.connect(g); g.connect(this.sfxGain); osc.start(now); osc.stop(now + 0.09);
            },

            playDeath() {
                if (!this.ctx || !this.isPlaying || this.isMuted) return;
                const freq = 150 + Math.random() * 100;
                const osc = this.ctx.createOscillator(), g = this.ctx.createGain(), now = this.ctx.currentTime;
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(freq, now); osc.frequency.exponentialRampToValueAtTime(freq * 0.4, now + 0.12);
                g.gain.setValueAtTime(0.03, now); g.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
                osc.connect(g); g.connect(this.sfxGain); osc.start(now); osc.stop(now + 0.13);
            }
        };

        // FX Particle overlay system
        const FXCanvas = document.getElementById('fxCanvas');
        const fxCtx = FXCanvas.getContext('2d');
        FXCanvas.width = window.innerWidth; FXCanvas.height = window.innerHeight;
        window.addEventListener('resize', () => { FXCanvas.width = window.innerWidth; FXCanvas.height = window.innerHeight; });

        const FXParticles = [];
        function spawnFXParticle(x, y, color, type) {
            FXParticles.push({
                x, y,
                vx: (Math.random() - 0.5) * (type === 'birth' ? 3 : 1.5),
                vy: (Math.random() - 0.5) * (type === 'birth' ? 3 : 1.5) - (type === 'birth' ? 1 : 0),
                life: type === 'birth' ? 40 : 25,
                maxLife: type === 'birth' ? 40 : 25,
                color,
                size: type === 'birth' ? 3 + Math.random() * 3 : 2 + Math.random() * 2,
                type
            });
        }

        function drawFX() {
            fxCtx.clearRect(0, 0, FXCanvas.width, FXCanvas.height);
            for (let i = FXParticles.length - 1; i >= 0; i--) {
                const p = FXParticles[i];
                p.x += p.vx; p.y += p.vy;
                p.vx *= 0.95; p.vy *= 0.95;
                p.life--;
                if (p.life <= 0) { FXParticles.splice(i, 1); continue; }
                const alpha = p.life / p.maxLife;
                fxCtx.beginPath();
                fxCtx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
                fxCtx.fillStyle = p.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
                fxCtx.fill();
                if (p.type === 'birth') {
                    fxCtx.beginPath();
                    fxCtx.arc(p.x, p.y, p.size * 2 * alpha, 0, Math.PI * 2);
                    fxCtx.strokeStyle = p.color + Math.floor(alpha * 128).toString(16).padStart(2, '0');
                    fxCtx.lineWidth = 1;
                    fxCtx.stroke();
                }
            }
        }

        // Hook FX into the main loop
        const _origLoop = loop;
        let _birthAccum = 0, _deathAccum = 0;
        function loop(timestamp) {
            const prevBirths = births, prevDeaths = deaths;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            fps = Math.round(1000 / deltaTime);
            document.getElementById('fps').textContent = fps;

            if (isPlaying) {
                const newBirths = births - prevBirths;
                const newDeaths = deaths - prevDeaths;
                for (let i = 0; i < CONFIG.speed; i++) { update(); }

                // Spawn FX for births/deaths
                if (births > prevBirths && particles.length > 0) {
                    const sample = particles[Math.floor(Math.random() * particles.length)];
                    const col = SPECIES[sample.type]?.color || '#00ff88';
                    spawnFXParticle(sample.x, sample.y, col, 'birth');
                    if (births % 5 === 0) ElectroAudio.playBirth();
                }
                if (deaths > prevDeaths && Math.random() < 0.3) {
                    spawnFXParticle(Math.random() * width, Math.random() * height, '#ff3333', 'death');
                    if (deaths % 10 === 0) ElectroAudio.playDeath();
                }
            }

            draw();
            drawFX();

            if (generation % 10 === 0) updateStats();
            requestAnimationFrame(loop);
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', e => {
            if (e.key === 'm' || e.key === 'M') ElectroAudio.toggle();
            if (e.key === ' ' && !e.target.matches('input,select,textarea')) { e.preventDefault(); togglePlay(); }
            if (e.key === 'r' || e.key === 'R') loadPreset('random');
        });

        // CSS animation for music button
        const style = document.createElement('style');
        style.textContent = `
            @keyframes musicPulse2d {
                0%,100% { box-shadow: 0 0 5px rgba(255,0,255,0.3); }
                50% { box-shadow: 0 0 20px rgba(255,0,255,0.8), 0 0 40px rgba(255,0,255,0.3); }
            }
        `;
        document.head.appendChild(style);

        // Auto-start music on first user interaction
        let _audioReady = false;
        function _initAudio() {
            if (_audioReady) return; _audioReady = true;
            ElectroAudio.startMusic();
            document.removeEventListener('click', _initAudio);
            document.removeEventListener('keydown', _initAudio);
        }
        document.addEventListener('click', _initAudio);
        document.addEventListener('keydown', _initAudio);
    </script>
</body>
</html>