
        // ==================== EPIC MEDIEVAL AUDIO SYSTEM ====================
        class MedievalAudioSystem {
            constructor() {
                this.ctx = null;   // created lazily on first user interaction
                this.masterGain = null;
                this._volume = 0.2;
                this.isPlaying = false;
                this.currentSection = 0;
                this.nextNoteTime = 0;
                this.bpm = 80; // Slow, epic tempo
                this.timerID = null;
                
                // Chord progressions for epic orchestral feel
                this.chordProgressions = [
                    // Epic intro progression
                    [
                        { root: 65.41, type: 'minor', notes: [65.41, 77.78, 98.00, 116.54] }, // Dm
                        { root: 55.00, type: 'major', notes: [55.00, 69.30, 82.41, 110.00] }, // A
                        { root: 73.42, type: 'minor', notes: [73.42, 87.31, 110.00, 130.81] }, // Cm
                        { root: 49.00, type: 'minor', notes: [49.00, 58.27, 73.42, 87.31] }   // Gm
                    ],
                    // Battle progression
                    [
                        { root: 41.20, type: 'minor', notes: [41.20, 49.00, 61.74, 73.42] },   // E low
                        { root: 55.00, type: 'minor', notes: [55.00, 65.41, 82.41, 98.00] },   // A
                        { root: 65.41, type: 'minor', notes: [65.41, 77.78, 98.00, 116.54] }, // Dm
                        { root: 49.00, type: 'minor', notes: [49.00, 58.27, 73.42, 87.31] }   // G
                    ]
                ];
                
                this.currentProgression = 0;
                this.beatCount = 0;
                
                // Buffers created lazily after ctx exists
                this.swordSwingBuffer = null;
                this.arrowWhooshBuffer = null;
            }

            _ensureCtx() {
                if (this.ctx) return;
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                this.masterGain = this.ctx.createGain();
                this.masterGain.connect(this.ctx.destination);
                this.masterGain.gain.value = this._volume;
                // Build buffers now that ctx exists
                this.swordSwingBuffer  = this.createNoiseBuffer(0.1, 'white');
                this.arrowWhooshBuffer = this.createNoiseBuffer(0.15, 'pink');
            }
            
            createNoiseBuffer(duration, type) {
                const bufferSize = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    let white = Math.random() * 2 - 1;
                    if (type === 'pink') {
                        // Pink noise approximation
                        data[i] = (white + (data[i-1] || 0)) / 2 * 0.5;
                    } else {
                        data[i] = white;
                    }
                }
                return buffer;
            }
            
            // Play a string ensemble-like sound
            playString(freq, duration, volume = 0.3, delay = 0) {
                const now = this.ctx.currentTime + delay;
                
                // Main oscillator (sawtooth for string texture)
                const osc = this.ctx.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.value = freq;
                
                // Filter for string-like quality
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 800 + Math.random() * 400;
                filter.Q.value = 1;
                
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(volume, now + 0.3);
                gain.gain.exponentialRampToValueAtTime(volume * 0.7, now + duration * 0.7);
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start(now);
                osc.stop(now + duration);
                
                // Add subtle vibrato
                const vibrato = this.ctx.createOscillator();
                vibrato.frequency.value = 5;
                const vibratoGain = this.ctx.createGain();
                vibratoGain.gain.value = freq * 0.01;
                vibrato.connect(vibratoGain);
                vibratoGain.connect(osc.frequency);
                vibrato.start(now);
                vibrato.stop(now + duration);
            }
            
            // Play brass/horn sound
            playBrass(freq, duration, volume = 0.25, delay = 0) {
                const now = this.ctx.currentTime + delay;
                
                const osc = this.ctx.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.value = freq;
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(200, now);
                filter.frequency.linearRampToValueAtTime(600, now + 0.1);
                filter.frequency.exponentialRampToValueAtTime(400, now + duration);
                
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(volume, now + 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start(now);
                osc.stop(now + duration);
            }
            
            // Play choral pad
            playChoir(freq, duration, volume = 0.2, delay = 0) {
                const now = this.ctx.currentTime + delay;
                
                // Multiple oscillators for choir effect
                const freqs = [freq, freq * 1.005, freq * 0.995];
                
                freqs.forEach((f, i) => {
                    const osc = this.ctx.createOscillator();
                    osc.type = i === 0 ? 'sine' : 'triangle';
                    osc.frequency.value = f;
                    
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 1200;
                    
                    const gain = this.ctx.createGain();
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(volume * (i === 0 ? 1 : 0.5), now + 0.5);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
                    
                    osc.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.masterGain);
                    
                    osc.start(now);
                    osc.stop(now + duration);
                });
            }
            
            // Epic drum hit
            playDrum(type, delay = 0) {
                const now = this.ctx.currentTime + delay;
                
                if (type === 'timpani') {
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(80, now);
                    osc.frequency.exponentialRampToValueAtTime(40, now + 0.5);
                    
                    const gain = this.ctx.createGain();
                    gain.gain.setValueAtTime(0.5, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 1);
                    
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    
                    osc.start(now);
                    osc.stop(now + 1);
                } else if (type === 'snare') {
                    const buffer = this.createNoiseBuffer(0.2, 'white');
                    const source = this.ctx.createBufferSource();
                    source.buffer = buffer;
                    
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'highpass';
                    filter.frequency.value = 1000;
                    
                    const gain = this.ctx.createGain();
                    gain.gain.setValueAtTime(0.3, now);
                    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                    
                    source.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.masterGain);
                    
                    source.start(now);
                }
            }
            
            // Battle sound effects
            playBattleHorn() {
                this._ensureCtx();
                const now = this.ctx.currentTime;
                [220, 329.63, 440].forEach((freq, i) => {
                    this.playBrass(freq, 1.5, 0.4, i * 0.15);
                });
            }
            
            playSwordClash() {
                this._ensureCtx();
                const now = this.ctx.currentTime;
                
                // Metallic clang
                const osc = this.ctx.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(800, now);
                osc.frequency.exponentialRampToValueAtTime(200, now + 0.3);
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 1000;
                filter.Q.value = 10;
                
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.3, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start(now);
                osc.stop(now + 0.3);
                
                // Add noise for texture
                const noise = this.ctx.createBufferSource();
                noise.buffer = this.swordSwingBuffer;
                const noiseGain = this.ctx.createGain();
                noiseGain.gain.setValueAtTime(0.2, now);
                noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
                noise.connect(noiseGain);
                noiseGain.connect(this.masterGain);
                noise.start(now);
            }
            
            playArrowShot() {
                const now = this.ctx.currentTime;
                
                const osc = this.ctx.createOscillator();
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(400, now);
                osc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
                
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.15, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start(now);
                osc.stop(now + 0.3);
            }
            
            playCastleUpgrade() {
                const now = this.ctx.currentTime;
                // Victory fanfare
                [523.25, 659.25, 783.99, 1046.50].forEach((freq, i) => {
                    this.playBrass(freq, 2, 0.3, i * 0.2);
                });
            }
            
            playRecruitSound(unitType) {
                const now = this.ctx.currentTime;
                const freqs = {
                    'knight': [196, 293.66], // G to D
                    'archer': [329.63, 392], // E to G
                    'cavalry': [130.81, 196], // C to G
                    'spy': [261.63, 311.13] // C to D#
                };
                
                const notes = freqs[unitType] || [261.63, 329.63];
                notes.forEach((freq, i) => {
                    this.playString(freq, 0.5, 0.2, i * 0.1);
                });
            }
            
            // Scheduler for background music
            scheduler() {
                while (this.nextNoteTime < this.ctx.currentTime + 0.1) {
                    this.playMusicBeat(this.beatCount, this.nextNoteTime);
                    this.nextNoteTime += 60 / this.bpm / 2; // 8th notes
                    this.beatCount++;
                }
                if (this.isPlaying) {
                    this.timerID = requestAnimationFrame(() => this.scheduler());
                }
            }
            
            playMusicBeat(beat, time) {
                const eighth = beat % 8;
                const measure = Math.floor(beat / 8) % 16;
                const progression = this.chordProgressions[this.currentProgression];
                const chordIndex = Math.floor(measure / 4) % progression.length;
                const chord = progression[chordIndex];
                
                const delay = (time - this.ctx.currentTime) * 1000;
                
                // Play chords on measure start
                if (eighth === 0) {
                    // Bass notes
                    setTimeout(() => this.playString(chord.root, 4, 0.25), delay);
                    
                    // Chord tones
                    chord.notes.slice(1).forEach((note, i) => {
                        setTimeout(() => this.playString(note, 3.5, 0.15 - i * 0.02), delay + i * 50);
                    });
                    
                    // Occasional brass
                    if (measure % 8 === 0) {
                        setTimeout(() => this.playBrass(chord.root * 2, 2, 0.2), delay);
                    }
                    
                    // Choir pad every other measure
                    if (measure % 2 === 0) {
                        setTimeout(() => this.playChoir(chord.root * 2, 4, 0.15), delay);
                    }
                }
                
                // Timpani on beats 0 and 4
                if (eighth === 0 || eighth === 4) {
                    setTimeout(() => this.playDrum('timpani'), delay);
                }
                
                // Snare on beat 4 (backbeat)
                if (eighth === 4 && measure % 2 === 1) {
                    setTimeout(() => this.playDrum('snare'), delay);
                }
                
                // Switch progressions occasionally
                if (measure === 15 && eighth === 7) {
                    this.currentProgression = (this.currentProgression + 1) % this.chordProgressions.length;
                }
            }
            
            start() {
                this._ensureCtx();
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
                this.isPlaying = true;
                this.nextNoteTime = this.ctx.currentTime;
                this.beatCount = 0;
                this.scheduler();
            }
            
            stop() {
                this.isPlaying = false;
                if (this.timerID) {
                    cancelAnimationFrame(this.timerID);
                }
            }
            
            setVolume(val) {
                this._volume = val / 100;
                if (this.masterGain) this.masterGain.gain.value = this._volume;
            }
        }
        
        // ==================== GAME STATE ====================
        const gameState = {
            resources: {
                prestige: 100,
                gold: 500,
                wood: 200,
                stone: 150,
                food: 200,
                population: 50,
                maxPopulation: 100
            },
            army: {
                knights: 0,
                archers: 0,
                cavalry: 0,
                spies: 0
            },
            castle: {
                level: 1,
                defense: 10,
                garrison: 0,
                progress: 0
            },
            buildings: {
                barracks: false,
                stables: false,
                archeryRange: false,
                marketplace: false,
                blacksmith: false,
                temple: false
            },
            techs: {},
            diplomacy: {},
            heroes: [],
            turn: 1,
            year: 1,
            season: 0,
            seasons: ['Spring', 'Summer', 'Fall', 'Winter'],
            selectedKingdom: null,
            audio: null,
            musicEnabled: false
        };
        
        // ==================== INITIALIZATION ====================
        document.addEventListener('DOMContentLoaded', () => {
            gameState.audio = new MedievalAudioSystem();
            initializeGame();
            setupEventListeners();
            setupKeyboardControls();
            drawMap();
            updateUI();
        });
        
        function initializeGame() {
            // Initialize kingdoms
            const kingdomNames = ['Aldoria', 'Brenheim', 'Calador', 'Drakenmoor', 'Eldoria', 'Frostgarde'];
            kingdomNames.forEach((name, i) => {
                if (i > 0) { // Skip player kingdom
                    gameState.diplomacy[name] = {
                        status: 'neutral',
                        relation: 0,
                        color: `hsl(${i * 60}, 70%, 50%)`,
                        x: 200 + Math.random() * 600,
                        y: 150 + Math.random() * 400,
                        army: Math.floor(Math.random() * 20) + 10,
                        gold: Math.floor(Math.random() * 300) + 200
                    };
                }
            });
            
            // Initialize heroes
            const heroNames = ['Sir Galahad', 'Lady Morgana', 'Thorin Ironbeard', 'Elara Swiftwind'];
            gameState.heroes = heroNames.map((name, i) => ({
                id: i,
                name: name,
                level: 1,
                xp: 0,
                maxXp: 100,
                attack: 10 + Math.floor(Math.random() * 5),
                defense: 8 + Math.floor(Math.random() * 5),
                leadership: 5 + Math.floor(Math.random() * 5),
                assigned: false,
                abilities: ['Leadership I']
            }));
            
            updateTechTree();
            updateDiplomacy();
            updateBuildingsList();
        }
        
        function setupEventListeners() {
            // Music toggle
            document.getElementById('musicToggle').addEventListener('click', toggleMusic);
            document.getElementById('volumeSlider').addEventListener('input', (e) => {
                if (gameState.audio) {
                    gameState.audio.setVolume(e.target.value);
                }
            });
            
            // Unit recruitment
            document.getElementById('recruitKnight').addEventListener('click', () => recruitUnit('knight'));
            document.getElementById('recruitArcher').addEventListener('click', () => recruitUnit('archer'));
            document.getElementById('recruitCavalry').addEventListener('click', () => recruitUnit('cavalry'));
            document.getElementById('recruitSpy').addEventListener('click', () => recruitUnit('spy'));
            
            // Castle
            document.getElementById('upgradeCastle').addEventListener('click', upgradeCastle);
            document.getElementById('manageBuildings').addEventListener('click', () => openModal('buildingsModal'));
            document.getElementById('viewHeroes').addEventListener('click', () => openModal('heroModal'));
            
            // Turn
            document.getElementById('endTurnBtn').addEventListener('click', endTurn);
            document.getElementById('turnBasedBtn').addEventListener('click', () => setGameMode('turn'));
            document.getElementById('realTimeBtn').addEventListener('click', () => setGameMode('realtime'));
            
            // Save/Load/Reset
            document.getElementById('saveBtn').addEventListener('click', saveGame);
            document.getElementById('loadBtn').addEventListener('click', loadGame);
            document.getElementById('resetBtn').addEventListener('click', () => location.reload());
            
            // Canvas click
            document.getElementById('gameCanvas').addEventListener('click', handleMapClick);
            
            // Toggle switches
            document.getElementById('autoSaveToggle').addEventListener('click', function() {
                this.classList.toggle('active');
            });
            document.getElementById('fogToggle').addEventListener('click', function() {
                this.classList.toggle('active');
                drawMap();
            });
        }
        
        function setupKeyboardControls() {
            document.addEventListener('keydown', (e) => {
                // Prevent default for game keys
                if (['Space', 'KeyM', 'KeyH', 'KeyS', 'KeyL', 'KeyN'].includes(e.code)) {
                    e.preventDefault();
                }
                
                switch(e.code) {
                    case 'Space':
                        endTurn();
                        break;
                    case 'KeyM':
                        toggleMusic();
                        break;
                    case 'Digit1':
                        recruitUnit('knight');
                        break;
                    case 'Digit2':
                        recruitUnit('archer');
                        break;
                    case 'Digit3':
                        recruitUnit('cavalry');
                        break;
                    case 'Digit4':
                        recruitUnit('spy');
                        break;
                    case 'KeyH':
                        openModal('heroModal');
                        break;
                    case 'KeyS':
                        if (e.ctrlKey) {
                            e.preventDefault();
                            saveGame();
                        }
                        break;
                    case 'KeyL':
                        if (e.ctrlKey) {
                            e.preventDefault();
                            loadGame();
                        }
                        break;
                    case 'KeyN':
                        if (e.ctrlKey) {
                            e.preventDefault();
                            if (confirm('Start a new game?')) location.reload();
                        }
                        break;
                    case 'Escape':
                        document.querySelectorAll('.modal').forEach(m => m.classList.remove('active'));
                        break;
                }
            });
        }
        
        // ==================== AUDIO FUNCTIONS ====================
        function toggleMusic() {
            gameState.musicEnabled = !gameState.musicEnabled;
            const btn = document.getElementById('musicToggle');
            
            if (gameState.musicEnabled) {
                btn.textContent = 'üîä';
                btn.classList.remove('muted');
                gameState.audio.start();
            } else {
                btn.textContent = 'üéµ';
                btn.classList.add('muted');
                gameState.audio.stop();
            }
        }
        
        // ==================== GAME FUNCTIONS ====================
        function recruitUnit(type) {
            const costs = {
                knight: { gold: 50, food: 20 },
                archer: { gold: 30, food: 10 },
                cavalry: { gold: 80, food: 30 },
                spy: { gold: 100, wood: 50 }
            };
            
            const cost = costs[type];
            
            if (gameState.resources.gold >= cost.gold && 
                gameState.resources.food >= (cost.food || 0) &&
                gameState.resources.wood >= (cost.wood || 0) &&
                gameState.resources.population < gameState.resources.maxPopulation) {
                
                gameState.resources.gold -= cost.gold;
                gameState.resources.food -= cost.food || 0;
                gameState.resources.wood -= cost.wood || 0;
                gameState.resources.population++;
                
                if (type === 'knight') gameState.army.knights++;
                else if (type === 'archer') gameState.army.archers++;
                else if (type === 'cavalry') gameState.army.cavalry++;
                else if (type === 'spy') gameState.army.spies++;
                
                // Play recruit sound
                if (gameState.audio && gameState.musicEnabled) {
                    gameState.audio.playRecruitSound(type);
                }
                
                // Create particle effect
                createParticleEffect(window.innerWidth / 2, window.innerHeight / 2, '#ffd700');
                
                addEvent(`Recruited ${type.charAt(0).toUpperCase() + type.slice(1)}`, 'positive');
                updateUI();
            } else {
                addEvent('Not enough resources!', 'negative');
            }
        }
        
        function upgradeCastle() {
            const cost = gameState.castle.level * 200;
            if (gameState.resources.gold >= cost && gameState.resources.stone >= 100) {
                gameState.resources.gold -= cost;
                gameState.resources.stone -= 100;
                gameState.castle.progress += 25;
                
                if (gameState.castle.progress >= 100) {
                    gameState.castle.level++;
                    gameState.castle.defense += 5;
                    gameState.castle.progress = 0;
                    gameState.resources.maxPopulation += 20;
                    
                    // Play upgrade sound
                    if (gameState.audio && gameState.musicEnabled) {
                        gameState.audio.playCastleUpgrade();
                    }
                    
                    addEvent(`Castle upgraded to Level ${gameState.castle.level}!`, 'positive');
                } else {
                    addEvent(`Castle upgrade progress: ${gameState.castle.progress}%`, 'positive');
                }
                
                updateUI();
            } else {
                addEvent('Not enough resources for upgrade!', 'negative');
            }
        }
        
        function endTurn() {
            gameState.turn++;
            
            // Season progression
            if (gameState.turn % 4 === 0) {
                gameState.season = (gameState.season + 1) % 4;
                if (gameState.season === 0) gameState.year++;
            }
            
            // Income
            const income = 20 + (gameState.buildings.marketplace ? 15 : 0) + gameState.castle.level * 5;
            gameState.resources.gold += income;
            gameState.resources.food += 10;
            
            // Consumption
            const consumption = gameState.resources.population * 0.5;
            gameState.resources.food -= consumption;
            
            if (gameState.resources.food < 0) {
                gameState.resources.food = 0;
                addEvent('Food shortage! Population is starving!', 'negative');
                gameState.resources.population = Math.max(10, gameState.resources.population - 5);
            }
            
            // AI turns
            processAI();
            
            // Battle horn at start of war
            if (gameState.turn % 10 === 0 && gameState.audio && gameState.musicEnabled) {
                gameState.audio.playBattleHorn();
            }
            
            addEvent(`Turn ${gameState.turn} - Income: +${income} gold`, 'positive');
            updateUI();
            drawMap();
        }
        
        function processAI() {
            Object.entries(gameState.diplomacy).forEach(([name, data]) => {
                // Random diplomatic shifts
                if (Math.random() < 0.1) {
                    data.relation += Math.floor(Math.random() * 10) - 5;
                    
                    if (data.relation < -30 && data.status !== 'war') {
                        data.status = 'war';
                        addEvent(`${name} has declared war!`, 'negative');
                        
                        // Play battle horn
                        if (gameState.audio && gameState.musicEnabled) {
                            gameState.audio.playBattleHorn();
                        }
                        
                        // Battle flash
                        document.getElementById('battleFlash').classList.add('active');
                        setTimeout(() => document.getElementById('battleFlash').classList.remove('active'), 300);
                        
                        // Sword clash sounds
                        if (gameState.audio && gameState.musicEnabled) {
                            gameState.audio.playSwordClash();
                            setTimeout(() => gameState.audio.playSwordClash(), 200);
                        }
                    } else if (data.relation > 30 && data.status === 'war') {
                        data.status = 'neutral';
                        addEvent(`${name} seeks peace!`, 'positive');
                    }
                }
            });
            
            updateDiplomacy();
        }
        
        function handleMapClick(e) {
            const canvas = document.getElementById('gameCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if clicked on a kingdom
            Object.entries(gameState.diplomacy).forEach(([name, data]) => {
                const dx = x - data.x;
                const dy = y - data.y;
                if (Math.sqrt(dx*dx + dy*dy) < 30) {
                    gameState.selectedKingdom = name;
                    showKingdomActions(name);
                }
            });
        }
        
        function showKingdomActions(name) {
            const data = gameState.diplomacy[name];
            const action = prompt(`Kingdom: ${name}\nStatus: ${data.status}\nRelation: ${data.relation}\n\nActions: (war, ally, trade, spy)`);
            
            if (action === 'war' && data.status !== 'war') {
                data.status = 'war';
                data.relation = -50;
                addEvent(`Declared war on ${name}!`, 'negative');
                
                if (gameState.audio && gameState.musicEnabled) {
                    gameState.audio.playBattleHorn();
                    gameState.audio.playSwordClash();
                }
                
                document.getElementById('battleFlash').classList.add('active');
                setTimeout(() => document.getElementById('battleFlash').classList.remove('active'), 300);
            }
            
            updateDiplomacy();
            drawMap();
        }
        
        // ==================== UI UPDATES ====================
        function updateUI() {
            document.getElementById('prestige').textContent = gameState.resources.prestige;
            document.getElementById('gold').textContent = gameState.resources.gold;
            document.getElementById('wood').textContent = gameState.resources.wood;
            document.getElementById('stone').textContent = gameState.resources.stone;
            document.getElementById('food').textContent = Math.floor(gameState.resources.food);
            document.getElementById('population').textContent = `${gameState.resources.population}/${gameState.resources.maxPopulation}`;
            document.getElementById('armySize').textContent = gameState.army.knights + gameState.army.archers + gameState.army.cavalry;
            document.getElementById('spyCount').textContent = gameState.army.spies;
            document.getElementById('castleLevel').textContent = `Level ${gameState.castle.level}`;
            document.getElementById('castleDefense').textContent = gameState.castle.defense;
            document.getElementById('garrisonSize').textContent = gameState.castle.garrison;
            document.getElementById('castleProgress').style.width = `${gameState.castle.progress}%`;
            document.getElementById('turnNumber').textContent = `Turn ${gameState.turn}`;
            document.getElementById('gameDate').textContent = `Year ${gameState.year}, ${gameState.seasons[gameState.season]}`;
            document.getElementById('victoryStatus').textContent = `Conquest: ${Object.values(gameState.diplomacy).filter(d => d.status === 'war').length}/5`;
            
            // Update victory progress
            document.getElementById('dominationProgress').textContent = `${Object.values(gameState.diplomacy).filter(d => d.status === 'war').length}/5 kingdoms`;
            document.getElementById('economicProgress').textContent = `${gameState.resources.gold}/5000 gold`;
            document.getElementById('culturalProgress').textContent = `${gameState.resources.prestige}/1000 prestige`;
        }
        
        function updateDiplomacy() {
            const list = document.getElementById('diplomacyList');
            list.innerHTML = '';
            
            Object.entries(gameState.diplomacy).forEach(([name, data]) => {
                const div = document.createElement('div');
                div.className = `diplomacy-item ${data.status}`;
                div.innerHTML = `
                    <div class="diplomacy-header">
                        <strong style="color: ${data.color}">${name}</strong>
                        <span>${data.status.toUpperCase()}</span>
                    </div>
                    <div style="font-size: 10px; color: #888;">Relation: ${data.relation}</div>
                `;
                list.appendChild(div);
            });
        }
        
        function updateTechTree() {
            const tree = document.getElementById('techTree');
            const techs = [
                { id: 'iron', name: '‚öîÔ∏è', desc: 'Iron Weapons' },
                { id: 'archery', name: 'üèπ', desc: 'Advanced Archery' },
                { id: 'cavalry', name: 'üê¥', desc: 'Heavy Cavalry' },
                { id: 'siege', name: 'üè∞', desc: 'Siege Craft' },
                { id: 'trade', name: 'üí∞', desc: 'Trade Routes' },
                { id: 'diplomacy', name: 'üìú', desc: 'Diplomacy' },
                { id: 'espionage', name: 'üïµÔ∏è', desc: 'Espionage' },
                { id: 'medicine', name: 'üè•', desc: 'Medicine' },
                { id: 'agriculture', name: 'üåæ', desc: 'Agriculture' }
            ];
            
            tree.innerHTML = techs.map(tech => `
                <div class="tech-node ${gameState.techs[tech.id] ? 'researched' : ''}" onclick="researchTech('${tech.id}')">
                    <div style="font-size: 16px;">${tech.name}</div>
                    <div style="font-size: 8px;">${tech.desc}</div>
                </div>
            `).join('');
        }
        
        function researchTech(techId) {
            if (!gameState.techs[techId] && gameState.resources.gold >= 100) {
                gameState.resources.gold -= 100;
                gameState.techs[techId] = true;
                addEvent(`Researched ${techId}!`, 'positive');
                updateTechTree();
                updateUI();
            }
        }
        
        function updateBuildingsList() {
            const list = document.getElementById('buildingsList');
            if (!list) return;
            
            const buildings = [
                { id: 'barracks', name: 'Barracks', cost: '100ü™ô 50ü™µ' },
                { id: 'stables', name: 'Stables', cost: '150ü™ô 80ü™µ' },
                { id: 'archeryRange', name: 'Archery Range', cost: '120ü™ô 60ü™µ' },
                { id: 'marketplace', name: 'Marketplace', cost: '200ü™ô' },
                { id: 'blacksmith', name: 'Blacksmith', cost: '180ü™ô 100ü™®' },
                { id: 'temple', name: 'Temple', cost: '250ü™ô 100ü™®' }
            ];
            
            list.innerHTML = buildings.map(b => `
                <div class="building-item ${gameState.buildings[b.id] ? 'built' : ''}" onclick="build('${b.id}')">
                    <strong>${b.name}</strong>
                    <div style="font-size: 9px; color: #888;">${b.cost}</div>
                </div>
            `).join('');
        }
        
        function build(buildingId) {
            if (!gameState.buildings[buildingId]) {
                gameState.buildings[buildingId] = true;
                addEvent(`Built ${buildingId}!`, 'positive');
                updateBuildingsList();
            }
        }
        
        // ==================== CANVAS MAP ====================
        function drawMap() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const container = document.getElementById('canvasContainer');
            
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            
            // Clear
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw terrain
            drawTerrain(ctx, canvas.width, canvas.height);
            
            // Draw connections
            ctx.strokeStyle = '#444';
            ctx.lineWidth = 1;
            Object.entries(gameState.diplomacy).forEach(([name1, data1]) => {
                Object.entries(gameState.diplomacy).forEach(([name2, data2]) => {
                    if (name1 < name2) {
                        ctx.beginPath();
                        ctx.moveTo(data1.x, data1.y);
                        ctx.lineTo(data2.x, data2.y);
                        ctx.stroke();
                    }
                });
            });
            
            // Draw kingdoms
            Object.entries(gameState.diplomacy).forEach(([name, data]) => {
                // Glow effect
                const gradient = ctx.createRadialGradient(data.x, data.y, 0, data.x, data.y, 40);
                gradient.addColorStop(0, data.color + '40');
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(data.x, data.y, 40, 0, Math.PI * 2);
                ctx.fill();
                
                // Kingdom circle
                ctx.fillStyle = data.color;
                ctx.beginPath();
                ctx.arc(data.x, data.y, 20, 0, Math.PI * 2);
                ctx.fill();
                
                // Border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Status indicator
                if (data.status === 'war') {
                    ctx.fillStyle = '#ff0000';
                    ctx.beginPath();
                    ctx.arc(data.x + 15, data.y - 15, 6, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Name
                ctx.fillStyle = '#fff';
                ctx.font = '12px Cinzel';
                ctx.textAlign = 'center';
                ctx.fillText(name, data.x, data.y + 35);
            });
            
            // Draw player castle
            const playerX = canvas.width / 2;
            const playerY = canvas.height / 2;
            
            // Castle glow
            const castleGradient = ctx.createRadialGradient(playerX, playerY, 0, playerX, playerY, 60);
            castleGradient.addColorStop(0, '#ffd70040');
            castleGradient.addColorStop(1, 'transparent');
            ctx.fillStyle = castleGradient;
            ctx.beginPath();
            ctx.arc(playerX, playerY, 60, 0, Math.PI * 2);
            ctx.fill();
            
            // Castle
            ctx.fillStyle = '#d4af37';
            ctx.fillRect(playerX - 25, playerY - 20, 50, 40);
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(playerX - 20, playerY - 30, 15, 20);
            ctx.fillRect(playerX + 5, playerY - 30, 15, 20);
            
            // Castle label
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 14px Cinzel';
            ctx.textAlign = 'center';
            ctx.fillText('YOUR KINGDOM', playerX, playerY + 50);
            
            // Update minimap
            updateMinimap();
        }
        
        function drawTerrain(ctx, width, height) {
            // Simple terrain pattern
            ctx.fillStyle = '#16213e';
            for (let i = 0; i < 50; i++) {
                const x = (i * 137) % width;
                const y = (i * 73) % height;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        function updateMinimap() {
            const canvas = document.getElementById('minimap');
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const scaleX = canvas.width / 800;
            const scaleY = canvas.height / 600;
            
            Object.entries(gameState.diplomacy).forEach(([name, data]) => {
                ctx.fillStyle = data.color;
                ctx.beginPath();
                ctx.arc(data.x * scaleX, data.y * scaleY, 4, 0, Math.PI * 2);
                ctx.fill();
            });
            
            ctx.fillStyle = '#ffd700';
            ctx.fillRect(canvas.width / 2 - 5, canvas.height / 2 - 5, 10, 10);
        }
        
        // ==================== UTILITIES ====================
        function createParticleEffect(x, y, color) {
            const container = document.getElementById('particlesContainer');
            
            for (let i = 0; i < 10; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                particle.style.background = color;
                particle.style.transform = `translate(${(Math.random() - 0.5) * 100}px, ${(Math.random() - 0.5) * 100}px)`;
                particle.style.transition = 'all 0.5s ease-out';
                container.appendChild(particle);
                
                setTimeout(() => {
                    particle.style.opacity = '0';
                    particle.style.transform = `translate(${(Math.random() - 0.5) * 200}px, ${(Math.random() - 0.5) * 200}px)`;
                }, 10);
                
                setTimeout(() => particle.remove(), 500);
            }
        }
        
        function addEvent(message, type = '') {
            const log = document.getElementById('eventLog');
            const entry = document.createElement('div');
            entry.className = `event-entry ${type}`;
            entry.textContent = `Turn ${gameState.turn}: ${message}`;
            log.insertBefore(entry, log.firstChild);
            
            while (log.children.length > 20) {
                log.removeChild(log.lastChild);
            }
        }
        
        function openModal(modalId) {
            document.getElementById(modalId).classList.add('active');
            
            if (modalId === 'heroModal') {
                updateHeroList();
            } else if (modalId === 'buildingsModal') {
                updateBuildingsList();
            }
        }
        
        function closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }
        
        function updateHeroList() {
            const list = document.getElementById('heroList');
            list.innerHTML = gameState.heroes.map(hero => `
                <div class="hero-card">
                    <div class="hero-header">
                        <span class="hero-name">${hero.name}</span>
                        <span class="hero-level">Lv ${hero.level}</span>
                    </div>
                    <div class="hero-stats">
                        <div>‚öîÔ∏è Attack: ${hero.attack}</div>
                        <div>üõ°Ô∏è Defense: ${hero.defense}</div>
                        <div>üëë Leadership: ${hero.leadership}</div>
                        <div>üìà XP: ${hero.xp}/${hero.maxXp}</div>
                    </div>
                    <div class="xp-bar">
                        <div class="xp-fill" style="width: ${(hero.xp / hero.maxXp) * 100}%"></div>
                    </div>
                    <div class="hero-abilities">
                        ${hero.abilities.map(a => `<div class="hero-ability">${a}</div>`).join('')}
                    </div>
                </div>
            `).join('');
        }
        
        function setGameMode(mode) {
            document.getElementById('turnBasedBtn').classList.toggle('active', mode === 'turn');
            document.getElementById('realTimeBtn').classList.toggle('active', mode === 'realtime');
        }
        
        function saveGame() {
            localStorage.setItem('medievalWars_save', JSON.stringify(gameState));
            document.getElementById('saveStatus').textContent = 'Game saved!';
            setTimeout(() => document.getElementById('saveStatus').textContent = '', 2000);
        }
        
        function loadGame() {
            const saved = localStorage.getItem('medievalWars_save');
            if (saved) {
                Object.assign(gameState, JSON.parse(saved));
                updateUI();
                updateDiplomacy();
                updateTechTree();
                drawMap();
                document.getElementById('saveStatus').textContent = 'Game loaded!';
                setTimeout(() => document.getElementById('saveStatus').textContent = '', 2000);
            }
        }
        
        // Handle window resize
        window.addEventListener('resize', drawMap);
    </script>

    <!-- Battle flash overlay (referenced by JS) -->
    <div id="battleFlash" style="
        position:fixed;top:0;left:0;width:100%;height:100%;
        background:rgba(255,50,50,0.18);pointer-events:none;
        z-index:9999;display:none;transition:opacity .15s;
    "></div>
    <style>
        #battleFlash.active { display:block; animation:flashAnim .3s ease forwards; }
        @keyframes flashAnim {
            0%   { opacity:1; }
            100% { opacity:0; }
        }
    </style>
</body>
</html>
