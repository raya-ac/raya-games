<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Traffic Simulator - City Management</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #0d1117;
            --bg-card: #161b22;
            --bg-panel: #21262d;
            --border: #30363d;
            --text: #c9d1d9;
            --text-muted: #8b949e;
            --accent: #58a6ff;
            --accent-green: #3fb950;
            --accent-red: #f85149;
            --accent-yellow: #d29922;
            --accent-orange: #f0883e;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-dark);
            color: var(--text);
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background: var(--bg-card);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .header {
            padding: 16px;
            border-bottom: 1px solid var(--border);
        }

        .header h1 {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--accent);
        }

        .header p {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 4px;
        }

        /* Tool sections */
        .tool-section {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
        }

        .tool-section h3 {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 10px;
        }

        .tool-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }

        .tool-btn {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 10px 4px;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text);
            font-size: 0.75rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .tool-btn:hover {
            background: var(--border);
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .tool-btn.active {
            background: var(--accent);
            color: #fff;
            border-color: var(--accent);
        }

        .tool-btn .icon {
            font-size: 1.2rem;
        }

        /* Metrics panel */
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .metric {
            background: var(--bg-panel);
            border-radius: 6px;
            padding: 8px;
            text-align: center;
            transition: all 0.3s;
        }

        .metric-value {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--accent-green);
            transition: all 0.3s;
        }

        .metric-label {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .metric.warning .metric-value {
            color: var(--accent-yellow);
        }

        .metric.danger .metric-value {
            color: var(--accent-red);
        }

        /* Controls */
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
        }

        .control-row label {
            flex: 1;
            color: var(--text-muted);
        }

        .control-row input[type="range"] {
            flex: 1;
            accent-color: var(--accent);
        }

        .control-row input[type="number"] {
            width: 50px;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 4px;
            color: var(--text);
            text-align: center;
        }

        /* Time display */
        .time-display {
            background: var(--bg-panel);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
            transition: all 0.5s;
        }

        .time-display.night {
            background: linear-gradient(135deg, #1a1f2e 0%, #2d1b4e 100%);
        }

        .time-display .time {
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--accent);
        }

        .time-display .phase {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 2px;
        }

        /* Action buttons */
        .actions {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 12px 16px;
        }

        .btn {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text);
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }

        .btn:hover {
            background: var(--border);
            transform: translateY(-1px);
        }

        .btn.primary {
            background: var(--accent);
            border-color: var(--accent);
            color: #fff;
        }

        .btn.primary:hover {
            background: #79b8ff;
        }

        .btn.danger {
            background: var(--accent-red);
            border-color: var(--accent-red);
            color: #fff;
        }

        .btn.danger:hover {
            background: #ff6b63;
        }

        .btn.music-active {
            background: linear-gradient(135deg, #8b5cf6, #6366f1);
            border-color: #8b5cf6;
            color: #fff;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(139, 92, 246, 0.4); }
            50% { box-shadow: 0 0 0 10px rgba(139, 92, 246, 0); }
        }

        /* Canvas area */
        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .toolbar {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .toolbar-btn {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            color: var(--text);
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s;
        }

        .toolbar-btn:hover {
            background: var(--border);
        }

        .toolbar-separator {
            width: 1px;
            height: 20px;
            background: var(--border);
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            background: #1a1f2e;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .modal-overlay.show {
            opacity: 1;
            pointer-events: auto;
        }

        .modal {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 24px;
            max-width: 400px;
            width: 90%;
        }

        .modal h2 {
            font-size: 1.1rem;
            margin-bottom: 16px;
        }

        .modal .form-group {
            margin-bottom: 12px;
        }

        .modal label {
            display: block;
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .modal input[type="text"],
        .modal textarea {
            width: 100%;
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px;
            color: var(--text);
            font-family: monospace;
            font-size: 0.85rem;
        }

        .modal textarea {
            height: 120px;
            resize: none;
        }

        .modal-actions {
            display: flex;
            gap: 8px;
            margin-top: 16px;
        }

        .modal-actions .btn {
            flex: 1;
        }

        /* Tooltip */
        .tooltip {
            position: absolute;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 0.75rem;
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        .tooltip.show {
            display: block;
        }

        /* Traffic light controls */
        .light-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .light-control {
            background: var(--bg-panel);
            border-radius: 6px;
            padding: 8px;
        }

        .light-control label {
            font-size: 0.65rem;
            color: var(--text-muted);
            text-transform: uppercase;
        }

        .light-control input {
            width: 100%;
            margin-top: 4px;
        }

        /* Back button */
        .back-btn {
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 50;
        }

        /* Speed indicator */
        .speed-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .speed-btn {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            color: var(--text);
            font-size: 0.8rem;
            transition: all 0.2s;
        }

        .speed-btn.active {
            background: var(--accent);
            color: #fff;
            border-color: var(--accent);
        }

        /* Event log */
        .event-log {
            max-height: 100px;
            overflow-y: auto;
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        .event-log .event {
            padding: 2px 0;
            border-bottom: 1px solid var(--border);
        }

        .event-log .event.warning {
            color: var(--accent-yellow);
        }

        .event-log .event.danger {
            color: var(--accent-red);
        }

        .event-log .event.success {
            color: var(--accent-green);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* Mini map */
        .minimap {
            position: absolute;
            bottom: 16px;
            right: 16px;
            width: 150px;
            height: 150px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
        }

        #minimapCanvas {
            width: 100%;
            height: 100%;
        }

        /* Loading screen */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-dark);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 0.5s;
        }

        .loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading p {
            margin-top: 16px;
            color: var(--text-muted);
        }

        /* Keyboard shortcuts hint */
        .shortcuts-hint {
            position: fixed;
            bottom: 180px;
            right: 16px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.7rem;
            color: var(--text-muted);
            z-index: 50;
            opacity: 0.8;
        }

        .shortcuts-hint kbd {
            background: var(--bg-panel);
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid var(--border);
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">
        <div class="loading-spinner"></div>
        <p>Loading Traffic Simulator...</p>
    </div>

    <a href="/games" class="btn back-btn">üéÆ Games</a>

    <div class="container">
        <aside class="sidebar">
            <div class="header">
                <h1>üö¶ Traffic Simulator</h1>
                <p>City Traffic Management System</p>
            </div>

            <div class="tool-section">
                <h3>Road Building</h3>
                <div class="tool-grid">
                    <button class="tool-btn active" data-tool="road">
                        <span class="icon">üõ£Ô∏è</span>
                        <span>Road</span>
                    </button>
                    <button class="tool-btn" data-tool="intersection">
                        <span class="icon">‚ûï</span>
                        <span>Intersect</span>
                    </button>
                    <button class="tool-btn" data-tool="highway">
                        <span class="icon">üõ§Ô∏è</span>
                        <span>Highway</span>
                    </button>
                    <button class="tool-btn" data-tool="roundabout">
                        <span class="icon">üîÑ</span>
                        <span>Roundabout</span>
                    </button>
                    <button class="tool-btn" data-tool="bridge">
                        <span class="icon">üåâ</span>
                        <span>Bridge</span>
                    </button>
                    <button class="tool-btn" data-tool="tunnel">
                        <span class="icon">üöá</span>
                        <span>Tunnel</span>
                    </button>
                </div>
            </div>

            <div class="tool-section">
                <h3>Traffic Control</h3>
                <div class="tool-grid">
                    <button class="tool-btn" data-tool="trafficlight">
                        <span class="icon">üö•</span>
                        <span>Light</span>
                    </button>
                    <button class="tool-btn" data-tool="stop">
                        <span class="icon">üõë</span>
                        <span>Stop</span>
                    </button>
                    <button class="tool-btn" data-tool="crosswalk">
                        <span class="icon">üö∂</span>
                        <span>Cross</span>
                    </button>
                </div>
            </div>

            <div class="tool-section">
                <h3>Public Transport</h3>
                <div class="tool-grid">
                    <button class="tool-btn" data-tool="bus">
                        <span class="icon">üöå</span>
                        <span>Bus</span>
                    </button>
                    <button class="tool-btn" data-tool="metro">
                        <span class="icon">üöá</span>
                        <span>Metro</span>
                    </button>
                    <button class="tool-btn" data-tool="station">
                        <span class="icon">üöâ</span>
                        <span>Station</span>
                    </button>
                </div>
            </div>

            <div class="tool-section">
                <h3>Events</h3>
                <div class="tool-grid">
                    <button class="tool-btn" data-tool="accident">
                        <span class="icon">üí•</span>
                        <span>Crash</span>
                    </button>
                    <button class="tool-btn" data-tool="roadwork">
                        <span class="icon">üöß</span>
                        <span>Work</span>
                    </button>
                    <button class="tool-btn" data-tool="delete">
                        <span class="icon">üóëÔ∏è</span>
                        <span>Remove</span>
                    </button>
                </div>
            </div>

            <div class="tool-section">
                <h3>Time & Simulation</h3>
                <div class="time-display" id="timeDisplayContainer">
                    <div class="time" id="timeDisplay">08:00</div>
                    <div class="phase" id="phaseDisplay">Morning Rush</div>
                </div>
                <div class="control-group" style="margin-top: 12px;">
                    <div class="control-row">
                        <label>Time Speed:</label>
                        <div class="speed-control">
                            <button class="speed-btn" data-speed="0">‚è∏Ô∏è</button>
                            <button class="speed-btn active" data-speed="1">1x</button>
                            <button class="speed-btn" data-speed="2">2x</button>
                            <button class="speed-btn" data-speed="5">5x</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="tool-section">
                <h3>Traffic Metrics</h3>
                <div class="metrics-grid">
                    <div class="metric" id="metricSpeed">
                        <div class="metric-value" id="avgSpeed">45</div>
                        <div class="metric-label">km/h avg</div>
                    </div>
                    <div class="metric" id="metricCongestion">
                        <div class="metric-value" id="congestion">12%</div>
                        <div class="metric-label">congestion</div>
                    </div>
                    <div class="metric" id="metricEmissions">
                        <div class="metric-value" id="emissions">84</div>
                        <div class="metric-label">CO‚ÇÇ g/km</div>
                    </div>
                    <div class="metric" id="metricCars">
                        <div class="metric-value" id="carCount">0</div>
                        <div class="metric-label">vehicles</div>
                    </div>
                </div>
            </div>

            <div class="tool-section">
                <h3>Events Log</h3>
                <div class="event-log" id="eventLog">
                    <div class="event">Simulator initialized</div>
                </div>
            </div>

            <div class="actions">
                <button class="btn" id="btnMusic">üéµ Music: Off</button>
                <button class="btn" id="btnSFX">üîä SFX: On</button>
                <button class="btn" id="btnSave">üíæ Save City</button>
                <button class="btn" id="btnLoad">üìÇ Load City</button>
                <button class="btn danger" id="btnClear">üóëÔ∏è Clear All</button>
            </div>
        </aside>

        <main class="main-area">
            <div class="toolbar">
                <button class="toolbar-btn" id="btnPlay">‚ñ∂Ô∏è Play</button>
                <button class="toolbar-btn" id="btnPause">‚è∏Ô∏è Pause</button>
                <div class="toolbar-separator"></div>
                <button class="toolbar-btn" id="btnGrid">‚äû Grid</button>
                <button class="toolbar-btn" id="btnZoomIn">üîç+</button>
                <button class="toolbar-btn" id="btnZoomOut">üîç-</button>
                <div class="toolbar-separator"></div>
                <span style="font-size: 0.8rem; color: var(--text-muted);">
                    Tool: <span id="currentTool" style="color: var(--text);">Road</span>
                </span>
            </div>
            <div class="canvas-container">
                <canvas id="gameCanvas"></canvas>
                <div class="minimap">
                    <canvas id="minimapCanvas"></canvas>
                </div>
                <div class="shortcuts-hint">
                    <strong>Shortcuts:</strong><br>
                    <kbd>Space</kbd> Play/Pause<br>
                    <kbd>G</kbd> Toggle Grid<br>
                    <kbd>M</kbd> Toggle Music<br>
                    <kbd>S</kbd> Toggle SFX<br>
                    <kbd>+/-</kbd> Zoom<br>
                    <kbd>Del</kbd> Clear<br>
                    <kbd>1-6</kbd> Tools
                </div>
            </div>
        </main>
    </div>

    <!-- Save Modal -->
    <div class="modal-overlay" id="saveModal">
        <div class="modal">
            <h2>üíæ Save City</h2>
            <div class="form-group">
                <label>Save Code (copy this to load later):</label>
                <textarea id="saveCode" readonly></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" id="btnCopy">üìã Copy</button>
                <button class="btn primary" id="btnCloseSave">Close</button>
            </div>
        </div>
    </div>

    <!-- Load Modal -->
    <div class="modal-overlay" id="loadModal">
        <div class="modal">
            <h2>üìÇ Load City</h2>
            <div class="form-group">
                <label>Paste save code:</label>
                <textarea id="loadCode" placeholder="Paste your save code here..."></textarea>
            </div>
            <div class="modal-actions">
                <button class="btn" id="btnCloseLoad">Cancel</button>
                <button class="btn primary" id="btnConfirmLoad">Load</button>
            </div>
        </div>
    </div>

    <script>
        // Enhanced Audio System with City Ambience and Car Sounds
        class AudioSystem {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
                this.musicEnabled = false;
                this.sfxEnabled = true;
                this.volume = 0.2;
                this.sfxVolume = 0.3;
                
                // Music properties
                this.bpm = 80;
                this.beatInterval = 60 / this.bpm;
                this.nextBeatTime = 0;
                this.beatCount = 0;
                this.chordIndex = 0;
                this.scheduledNodes = [];
                this.isPlaying = false;
                
                // City ambience
                this.ambienceNode = null;
                this.trafficNoise = null;
                
                // Chord progression (city jazz vibes)
                this.chords = [
                    [261.63, 329.63, 392.00, 493.88], // Cmaj7
                    [220.00, 261.63, 329.63, 392.00], // Am7
                    [349.23, 440.00, 523.25, 659.25], // Fmaj7
                    [196.00, 246.94, 293.66, 349.23]  // G7
                ];
                
                // Car sound pool
                this.carSounds = [];
                this.lastCarSound = 0;
                this.horns = [];
            }

            init() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.setupMasterChain();
                }
            }

            setupMasterChain() {
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = this.volume;
                
                const compressor = this.ctx.createDynamicsCompressor();
                compressor.threshold.value = -24;
                compressor.knee.value = 30;
                compressor.ratio.value = 4;
                compressor.attack.value = 0.003;
                compressor.release.value = 0.25;
                
                this.masterGain.connect(compressor);
                compressor.connect(this.ctx.destination);
            }

            // City ambience: distant traffic hum
            createCityAmbience() {
                const bufferSize = 2 * this.ctx.sampleRate;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                // Create pink noise for city ambience
                let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
                for (let i = 0; i < bufferSize; i++) {
                    const white = Math.random() * 2 - 1;
                    b0 = 0.99886 * b0 + white * 0.0555179;
                    b1 = 0.99332 * b1 + white * 0.0750759;
                    b2 = 0.96900 * b2 + white * 0.1538520;
                    b3 = 0.86650 * b3 + white * 0.3104856;
                    b4 = 0.55000 * b4 + white * 0.5329522;
                    b5 = -0.7616 * b5 - white * 0.0168980;
                    data[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
                    data[i] *= 0.11;
                    b6 = white * 0.115926;
                }
                
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;
                
                // Lowpass filter for distant traffic sound
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400;
                filter.Q.value = 0.5;
                
                const gain = this.ctx.createGain();
                gain.gain.value = 0.03;
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                
                this.ambienceNode = noise;
                this.ambienceGain = gain;
                
                return noise;
            }

            // Car engine sound
            playCarSound(type = 'car') {
                if (!this.sfxEnabled || !this.ctx) return;
                
                const now = this.ctx.currentTime;
                if (now - this.lastCarSound < 0.1) return; // Throttle
                this.lastCarSound = now;
                
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                // Different engine sounds
                const freq = type === 'truck' ? 80 : type === 'bus' ? 60 : 100;
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(freq, now);
                osc.frequency.exponentialRampToValueAtTime(freq * 0.5, now + 0.3);
                
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(800, now);
                filter.frequency.exponentialRampToValueAtTime(200, now + 0.3);
                
                gain.gain.setValueAtTime(0.05, now);
                gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start(now);
                osc.stop(now + 0.3);
            }

            // Traffic light change sound
            playLightSound() {
                if (!this.sfxEnabled || !this.ctx) return;
                
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(1200, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(600, this.ctx.currentTime + 0.1);
                
                gain.gain.setValueAtTime(0.03, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start();
                osc.stop(this.ctx.currentTime + 0.1);
            }

            // Horn sound for traffic jams
            playHorn(congestionLevel) {
                if (!this.sfxEnabled || !this.ctx || congestionLevel < 30) return;
                if (Math.random() > congestionLevel / 100 * 0.1) return;
                
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(180, this.ctx.currentTime);
                
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.08, this.ctx.currentTime + 0.05);
                gain.gain.setValueAtTime(0.08, this.ctx.currentTime + 0.2);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start();
                osc.stop(this.ctx.currentTime + 0.5);
            }

            // Building/construction sound
            playBuildSound() {
                if (!this.sfxEnabled || !this.ctx) return;
                
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'square';
                osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(400, this.ctx.currentTime + 0.1);
                
                gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start();
                osc.stop(this.ctx.currentTime + 0.15);
            }

            // Crash sound
            playCrashSound() {
                if (!this.sfxEnabled || !this.ctx) return;
                
                // Noise burst for crash
                const bufferSize = this.ctx.sampleRate * 0.3;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.3));
                }
                
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1000;
                
                const gain = this.ctx.createGain();
                gain.gain.value = 0.2;
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                
                noise.start();
            }

            // Music functions
            playChord(time) {
                const chord = this.chords[this.chordIndex];
                const chordDuration = this.beatInterval * 4;
                
                chord.forEach((freq, i) => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    
                    gain.gain.setValueAtTime(0, time);
                    gain.gain.linearRampToValueAtTime(0.03, time + 0.5);
                    gain.gain.setValueAtTime(0.03, time + chordDuration - 0.5);
                    gain.gain.exponentialRampToValueAtTime(0.001, time + chordDuration);
                    
                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    
                    osc.start(time);
                    osc.stop(time + chordDuration);
                    
                    this.scheduledNodes.push(osc, gain);
                });
                
                this.chordIndex = (this.chordIndex + 1) % this.chords.length;
            }

            playKick(time) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(40, time + 0.1);
                
                gain.gain.setValueAtTime(0.04, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.15);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start(time);
                osc.stop(time + 0.2);
                
                this.scheduledNodes.push(osc, gain);
            }

            playSnare(time) {
                const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate);
                const data = noiseBuffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                
                const noise = this.ctx.createBufferSource();
                noise.buffer = noiseBuffer;
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 1000;
                
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.025, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.08);
                
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                
                noise.start(time);
                noise.stop(time + 0.1);
                
                this.scheduledNodes.push(noise, filter, gain);
            }

            scheduleBeat() {
                if (!this.musicEnabled || !this.isPlaying) return;
                
                const lookahead = 0.1;
                const currentTime = this.ctx.currentTime;
                
                while (this.nextBeatTime < currentTime + lookahead) {
                    if (this.beatCount % 4 === 0 || this.beatCount % 4 === 2) {
                        this.playKick(this.nextBeatTime);
                    }
                    
                    if (this.beatCount % 4 === 1 || this.beatCount % 4 === 3) {
                        this.playSnare(this.nextBeatTime);
                    }
                    
                    if (this.beatCount % 4 === 0) {
                        this.playChord(this.nextBeatTime);
                    }
                    
                    this.nextBeatTime += this.beatInterval;
                    this.beatCount++;
                }
                
                requestAnimationFrame(() => this.scheduleBeat());
            }

            toggleMusic() {
                this.init();
                this.musicEnabled = !this.musicEnabled;
                
                if (this.musicEnabled) {
                    this.startMusic();
                } else {
                    this.stopMusic();
                }
                
                return this.musicEnabled;
            }

            toggleSFX() {
                this.sfxEnabled = !this.sfxEnabled;
                return this.sfxEnabled;
            }

            startMusic() {
                if (!this.ctx) return;
                this.stopMusic();
                this.isPlaying = true;
                
                // Start city ambience
                this.ambienceNode = this.createCityAmbience();
                this.ambienceNode.start();
                
                this.nextBeatTime = this.ctx.currentTime;
                this.beatCount = 0;
                this.chordIndex = 0;
                this.scheduleBeat();
            }

            stopMusic() {
                this.isPlaying = false;
                
                if (this.ambienceNode) {
                    try { this.ambienceNode.stop(); } catch (e) {}
                    this.ambienceNode = null;
                }
                
                this.scheduledNodes.forEach(node => {
                    try {
                        if (node.stop) node.stop();
                        if (node.disconnect) node.disconnect();
                    } catch (e) {}
                });
                this.scheduledNodes = [];
            }

            setVolume(vol) {
                this.volume = vol;
                if (this.masterGain) {
                    this.masterGain.gain.value = vol;
                }
            }
        }

        // Traffic Simulator Game
        class TrafficSimulator {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.minimap = document.getElementById('minimapCanvas');
                this.minimapCtx = this.minimap.getContext('2d');
                
                this.camera = { x: 0, y: 0, zoom: 1 };
                this.gridSize = 40;
                this.showGrid = true;
                
                this.currentTool = 'road';
                this.isPlaying = true;
                this.timeSpeed = 1;
                this.gameTime = 8 * 60;
                
                this.roads = [];
                this.intersections = [];
                this.trafficLights = [];
                this.vehicles = [];
                this.buildings = [];
                this.events = [];
                this.busStops = [];
                this.metroLines = [];
                
                this.selectedCell = null;
                this.hoveredCell = null;
                
                this.audio = new AudioSystem();
                this.eventLog = [];
                
                this.particles = []; // Visual effects
                this.lastCongestion = 0;
                
                this.init();
            }

            init() {
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                this.setupInput();
                this.setupUI();
                this.setupKeyboard();
                
                this.createInitialCity();
                
                this.lastTime = performance.now();
                requestAnimationFrame((t) => this.loop(t));
                
                setTimeout(() => {
                    document.getElementById('loading').classList.add('hidden');
                }, 500);
            }

            resize() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                
                this.minimap.width = 150;
                this.minimap.height = 150;
            }

            setupInput() {
                let isDragging = false;
                let lastMouse = { x: 0, y: 0 };

                this.canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lastMouse = { x: e.clientX, y: e.clientY };
                    
                    if (e.button === 0) {
                        this.handleClick(e);
                    }
                });

                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const worldX = (x - this.canvas.width / 2 - this.camera.x) / this.camera.zoom;
                    const worldY = (y - this.canvas.height / 2 - this.camera.y) / this.camera.zoom;
                    this.hoveredCell = {
                        x: Math.floor(worldX / this.gridSize),
                        y: Math.floor(worldY / this.gridSize)
                    };
                    
                    if (isDragging && e.buttons === 2) {
                        this.camera.x += e.clientX - lastMouse.x;
                        this.camera.y += e.clientY - lastMouse.y;
                    }
                    
                    lastMouse = { x: e.clientX, y: e.clientY };
                });

                this.canvas.addEventListener('mouseup', () => {
                    isDragging = false;
                });

                this.canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomSpeed = 0.1;
                    const newZoom = this.camera.zoom * (e.deltaY > 0 ? 1 - zoomSpeed : 1 + zoomSpeed);
                    this.camera.zoom = Math.max(0.3, Math.min(3, newZoom));
                });

                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());
            }

            setupKeyboard() {
                document.addEventListener('keydown', (e) => {
                    switch(e.key) {
                        case ' ':
                            e.preventDefault();
                            this.isPlaying = !this.isPlaying;
                            break;
                        case 'g':
                        case 'G':
                            this.showGrid = !this.showGrid;
                            break;
                        case 'm':
                        case 'M':
                            document.getElementById('btnMusic').click();
                            break;
                        case 's':
                        case 'S':
                            document.getElementById('btnSFX').click();
                            break;
                        case '+':
                        case '=':
                            this.camera.zoom = Math.min(3, this.camera.zoom * 1.2);
                            break;
                        case '-':
                        case '_':
                            this.camera.zoom = Math.max(0.3, this.camera.zoom / 1.2);
                            break;
                        case 'Delete':
                        case 'Backspace':
                            this.clearCity();
                            break;
                        case '1':
                            this.selectTool('road');
                            break;
                        case '2':
                            this.selectTool('intersection');
                            break;
                        case '3':
                            this.selectTool('highway');
                            break;
                        case '4':
                            this.selectTool('trafficlight');
                            break;
                        case '5':
                            this.selectTool('bus');
                            break;
                        case '6':
                            this.selectTool('delete');
                            break;
                    }
                });
            }

            selectTool(tool) {
                const btn = document.querySelector(`.tool-btn[data-tool="${tool}"]`);
                if (btn) btn.click();
            }

            setupUI() {
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.currentTool = btn.dataset.tool;
                        
                        const toolNames = {
                            road: 'Road', intersection: 'Intersection', highway: 'Highway',
                            roundabout: 'Roundabout', bridge: 'Bridge', tunnel: 'Tunnel',
                            trafficlight: 'Traffic Light', stop: 'Stop Sign', crosswalk: 'Crosswalk',
                            bus: 'Bus Route', metro: 'Metro Line', station: 'Station',
                            accident: 'Accident', roadwork: 'Roadwork', delete: 'Delete'
                        };
                        document.getElementById('currentTool').textContent = toolNames[this.currentTool] || this.currentTool;
                        
                        // Play sound
                        this.audio.playBuildSound();
                    });
                });

                document.querySelectorAll('.speed-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        document.querySelectorAll('.speed-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        this.timeSpeed = parseInt(btn.dataset.speed);
                        this.isPlaying = this.timeSpeed > 0;
                    });
                });

                document.getElementById('btnPlay').addEventListener('click', () => { this.isPlaying = true; });
                document.getElementById('btnPause').addEventListener('click', () => { this.isPlaying = false; });
                document.getElementById('btnGrid').addEventListener('click', () => { this.showGrid = !this.showGrid; });
                document.getElementById('btnZoomIn').addEventListener('click', () => { this.camera.zoom = Math.min(3, this.camera.zoom * 1.2); });
                document.getElementById('btnZoomOut').addEventListener('click', () => { this.camera.zoom = Math.max(0.3, this.camera.zoom / 1.2); });

                document.getElementById('btnMusic').addEventListener('click', () => {
                    this.audio.init();
                    const enabled = this.audio.toggleMusic();
                    const btn = document.getElementById('btnMusic');
                    btn.textContent = enabled ? 'üéµ Music: On' : 'üéµ Music: Off';
                    btn.classList.toggle('music-active', enabled);
                });

                document.getElementById('btnSFX').addEventListener('click', () => {
                    this.audio.init();
                    const enabled = this.audio.toggleSFX();
                    document.getElementById('btnSFX').textContent = enabled ? 'üîä SFX: On' : 'üîä SFX: Off';
                });

                document.getElementById('btnSave').addEventListener('click', () => this.showSaveModal());
                document.getElementById('btnLoad').addEventListener('click', () => this.showLoadModal());
                document.getElementById('btnClear').addEventListener('click', () => this.clearCity());

                document.getElementById('btnCloseSave').addEventListener('click', () => {
                    document.getElementById('saveModal').classList.remove('show');
                });
                document.getElementById('btnCloseLoad').addEventListener('click', () => {
                    document.getElementById('loadModal').classList.remove('show');
                });
                document.getElementById('btnConfirmLoad').addEventListener('click', () => this.loadCity());
                document.getElementById('btnCopy').addEventListener('click', () => {
                    const saveCode = document.getElementById('saveCode');
                    saveCode.select();
                    document.execCommand('copy');
                    this.logEvent('Save code copied to clipboard!', 'success');
                });
            }

            createInitialCity() {
                const size = 12;
                for (let x = -size; x <= size; x++) {
                    for (let y = -size; y <= size; y++) {
                        if (x % 4 === 0 || y % 4 === 0) {
                            const type = (x % 8 === 0 && y % 8 === 0) ? 'intersection' : 
                                         (Math.abs(x) > 8 || Math.abs(y) > 8) ? 'highway' : 'road';
                            this.roads.push({ x, y, type, id: this.roads.length });
                            
                            if (x % 8 === 0 && y % 8 === 0) {
                                this.trafficLights.push({
                                    x, y,
                                    state: 'NS',
                                    timer: 0,
                                    nsDuration: 120,
                                    ewDuration: 100
                                });
                            }
                        }
                    }
                }

                for (let x = -size; x <= size; x += 4) {
                    for (let y = -size; y <= size; y += 4) {
                        if (x % 4 !== 0 && y % 4 !== 0 && Math.random() > 0.3) {
                            this.buildings.push({
                                x, y,
                                type: Math.random() > 0.5 ? 'residential' : 'commercial',
                                width: 2 + Math.random() * 2,
                                height: 2 + Math.random() * 3
                            });
                        }
                    }
                }

                for (let i = -8; i <= 8; i += 4) {
                    if (i !== 0) {
                        this.busStops.push({ x: i, y: 0 });
                        this.busStops.push({ x: 0, y: i });
                    }
                }

                this.logEvent('Initial city created', 'success');
            }

            handleClick(e) {
                if (!this.hoveredCell) return;
                
                const { x, y } = this.hoveredCell;
                
                switch (this.currentTool) {
                    case 'road':
                        this.addRoad(x, y, 'road');
                        break;
                    case 'highway':
                        this.addRoad(x, y, 'highway');
                        break;
                    case 'intersection':
                        this.addIntersection(x, y);
                        break;
                    case 'roundabout':
                        this.addRoundabout(x, y);
                        break;
                    case 'trafficlight':
                        this.addTrafficLight(x, y);
                        break;
                    case 'stop':
                        this.addStopSign(x, y);
                        break;
                    case 'delete':
                        this.removeAt(x, y);
                        break;
                    case 'accident':
                        this.addEvent(x, y, 'accident');
                        this.audio.playCrashSound();
                        break;
                    case 'roadwork':
                        this.addEvent(x, y, 'roadwork');
                        break;
                    case 'bus':
                        this.addBusStop(x, y);
                        break;
                    case 'metro':
                        this.addMetroStation(x, y);
                        break;
                }
            }

            addRoad(x, y, type) {
                const exists = this.roads.find(r => r.x === x && r.y === y);
                if (!exists) {
                    this.roads.push({ x, y, type, id: this.roads.length });
                    this.spawnVehicleAt(x, y);
                    this.createParticles(x, y, '#58a6ff');
                    this.audio.playBuildSound();
                }
            }

            addIntersection(x, y) {
                const exists = this.roads.find(r => r.x === x && r.y === y);
                if (exists) exists.type = 'intersection';
                else this.roads.push({ x, y, type: 'intersection', id: this.roads.length });
                this.audio.playBuildSound();
            }

            addRoundabout(x, y) {
                for (let dx = -1; dx <= 1; dx++) {
                    for (let dy = -1; dy <= 1; dy++) {
                        const rx = x + dx, ry = y + dy;
                        const exists = this.roads.find(r => r.x === rx && r.y === ry);
                        if (!exists) {
                            this.roads.push({ x: rx, y: ry, type: 'roundabout', id: this.roads.length });
                        }
                    }
                }
                this.logEvent('Roundabout built', 'success');
                this.audio.playBuildSound();
            }

            addTrafficLight(x, y) {
                const exists = this.trafficLights.find(l => l.x === x && l.y === y);
                if (!exists) {
                    this.trafficLights.push({
                        x, y, state: 'NS', timer: 0, nsDuration: 120, ewDuration: 100
                    });
                    this.logEvent('Traffic light installed', 'success');
                    this.audio.playBuildSound();
                }
            }

            addStopSign(x, y) {
                const road = this.roads.find(r => r.x === x && r.y === y);
                if (road) road.stopSign = true;
            }

            addBusStop(x, y) {
                const exists = this.busStops.find(s => s.x === x && s.y === y);
                if (!exists) {
                    this.busStops.push({ x, y });
                    this.logEvent('Bus stop added', 'success');
                    this.audio.playBuildSound();
                }
            }

            addMetroStation(x, y) {
                const exists = this.metroLines.find(m => m.x === x && m.y === y);
                if (!exists) {
                    this.metroLines.push({ x, y, type: 'station' });
                    this.logEvent('Metro station added', 'success');
                    this.audio.playBuildSound();
                }
            }

            addEvent(x, y, type) {
                this.events.push({
                    x, y, type,
                    duration: type === 'accident' ? 600 : 1200,
                    timer: 0
                });
                this.logEvent(`${type === 'accident' ? 'üí• Accident' : 'üöß Roadwork'} at (${x}, ${y})`, 'danger');
            }

            removeAt(x, y) {
                this.roads = this.roads.filter(r => r.x !== x || r.y !== y);
                this.trafficLights = this.trafficLights.filter(l => l.x !== x || l.y !== y);
                this.events = this.events.filter(e => e.x !== x || e.y !== y);
                this.busStops = this.busStops.filter(s => s.x !== x || s.y !== y);
                this.createParticles(x, y, '#f85149');
            }

            createParticles(x, y, color) {
                for (let i = 0; i < 8; i++) {
                    this.particles.push({
                        x: (x + 0.5) * this.gridSize,
                        y: (y + 0.5) * this.gridSize,
                        vx: (Math.random() - 0.5) * 4,
                        vy: (Math.random() - 0.5) * 4,
                        life: 1,
                        color: color
                    });
                }
            }

            spawnVehicleAt(x, y) {
                if (this.vehicles.length < 200) {
                    const type = Math.random() > 0.9 ? 'bus' : Math.random() > 0.8 ? 'truck' : 'car';
                    this.vehicles.push({
                        x: x * this.gridSize + this.gridSize / 2,
                        y: y * this.gridSize + this.gridSize / 2,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        speed: 0,
                        maxSpeed: 2 + Math.random() * 2,
                        targetSpeed: 2 + Math.random() * 2,
                        type: type,
                        path: [],
                        emissions: 0,
                        waitTime: 0,
                        color: this.getRandomCarColor()
                    });
                    
                    // Play car sound occasionally
                    if (Math.random() < 0.3) {
                        this.audio.playCarSound(type);
                    }
                }
            }

            getRandomCarColor() {
                const colors = ['#58a6ff', '#f85149', '#3fb950', '#f0883e', '#a371f7', '#d29922', '#fff'];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            update(deltaTime) {
                if (!this.isPlaying) return;
                
                const dt = deltaTime * this.timeSpeed;
                
                // Update game time
                this.gameTime += dt / 1000 * 0.5;
                if (this.gameTime >= 24 * 60) this.gameTime = 0;
                
                // Update traffic lights
                let lightChanged = false;
                this.trafficLights.forEach(light => {
                    light.timer += dt;
                    const duration = light.state === 'NS' ? light.nsDuration : light.ewDuration;
                    if (light.timer > duration) {
                        light.timer = 0;
                        light.state = light.state === 'NS' ? 'EW' : 'NS';
                        lightChanged = true;
                    }
                });
                
                if (lightChanged) {
                    this.audio.playLightSound();
                }

                // Update events
                this.events.forEach(e => e.timer += dt);
                this.events = this.events.filter(e => e.timer < e.duration);

                // Calculate traffic density
                const hour = Math.floor(this.gameTime / 60);
                const isRushHour = (hour >= 7 && hour <= 9) || (hour >= 17 && hour <= 19);
                const baseSpawnRate = isRushHour ? 0.15 : 0.05;

                // Spawn vehicles
                if (Math.random() < baseSpawnRate && this.vehicles.length < 200) {
                    const road = this.roads[Math.floor(Math.random() * this.roads.length)];
                    if (road) this.spawnVehicleAt(road.x, road.y);
                }

                // Update particles
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.05;
                });
                this.particles = this.particles.filter(p => p.life > 0);

                // Update vehicles
                let totalSpeed = 0;
                let stoppedCount = 0;
                let totalEmissions = 0;

                this.vehicles.forEach((v, i) => {
                    let minDist = Infinity;
                    let shouldStop = false;

                    this.vehicles.forEach((other, j) => {
                        if (i === j) return;
                        const dx = other.x - v.x;
                        const dy = other.y - v.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 30 && dist < minDist) {
                            minDist = dist;
                            if (dist < 20) shouldStop = true;
                        }
                    });

                    const gx = Math.floor(v.x / this.gridSize);
                    const gy = Math.floor(v.y / this.gridSize);
                    const light = this.trafficLights.find(l => l.x === gx && l.y === gy);
                    if (light) {
                        const approaching = (Math.abs(v.vx) > Math.abs(v.vy) && light.state !== 'EW') ||
                                           (Math.abs(v.vy) > Math.abs(v.vx) && light.state !== 'NS');
                        if (approaching && this.distanceToCenter(v, gx, gy) < 25) {
                            shouldStop = true;
                        }
                    }

                    const event = this.events.find(e => e.x === gx && e.y === gy);
                    if (event) shouldStop = true;

                    if (shouldStop) {
                        v.speed *= 0.9;
                        v.waitTime += dt;
                        if (v.speed < 0.1) {
                            v.speed = 0;
                            stoppedCount++;
                        }
                    } else {
                        const accel = 0.1;
                        if (v.speed < v.targetSpeed) v.speed += accel;
                        if (v.speed > v.targetSpeed) v.speed -= accel;
                        v.waitTime = Math.max(0, v.waitTime - dt);
                    }

                    if (v.speed > 0) {
                        const snapX = (gx + 0.5) * this.gridSize;
                        const snapY = (gy + 0.5) * this.gridSize;
                        
                        if (Math.abs(v.x - snapX) > 5) v.x += (snapX - v.x) * 0.1;
                        if (Math.abs(v.y - snapY) > 5) v.y += (snapY - v.y) * 0.1;
                        
                        const road = this.roads.find(r => r.x === gx && r.y === gy);
                        if (road && Math.random() < 0.05) {
                            const neighbors = this.roads.filter(r => 
                                Math.abs(r.x - gx) + Math.abs(r.y - gy) === 1
                            );
                            if (neighbors.length > 0) {
                                const next = neighbors[Math.floor(Math.random() * neighbors.length)];
                                v.vx = next.x > gx ? 1 : next.x < gx ? -1 : 0;
                                v.vy = next.y > gy ? 1 : next.y < gy ? -1 : 0;
                            }
                        }

                        v.x += v.vx * v.speed;
                        v.y += v.vy * v.speed;
                    }

                    const newGx = Math.floor(v.x / this.gridSize);
                    const newGy = Math.floor(v.y / this.gridSize);
                    const onRoad = this.roads.some(r => r.x === newGx && r.y === newGy);
                    if (!onRoad) {
                        v.offRoad = true;
                    }

                    const emissionRate = v.type === 'truck' ? 2 : v.type === 'bus' ? 1.5 : 1;
                    v.emissions += v.speed * emissionRate * dt / 1000;
                    totalEmissions += v.emissions;

                    totalSpeed += v.speed;
                });

                this.vehicles = this.vehicles.filter(v => !v.offRoad);

                // Update metrics
                const avgSpeed = this.vehicles.length > 0 ? totalSpeed / this.vehicles.length : 0;
                const congestion = this.vehicles.length > 0 ? (stoppedCount / this.vehicles.length) * 100 : 0;
                const avgEmissions = this.vehicles.length > 0 ? totalEmissions / this.vehicles.length : 0;

                this.updateMetrics(avgSpeed * 20, congestion, avgEmissions, this.vehicles.length);
                
                // Play horn sounds based on congestion
                this.audio.playHorn(congestion);
                this.lastCongestion = congestion;
            }

            distanceToCenter(vehicle, gx, gy) {
                const cx = (gx + 0.5) * this.gridSize;
                const cy = (gy + 0.5) * this.gridSize;
                const dx = vehicle.x - cx;
                const dy = vehicle.y - cy;
                return Math.sqrt(dx * dx + dy * dy);
            }

            updateMetrics(avgSpeed, congestion, emissions, count) {
                document.getElementById('avgSpeed').textContent = Math.round(avgSpeed);
                document.getElementById('congestion').textContent = Math.round(congestion) + '%';
                document.getElementById('emissions').textContent = Math.round(emissions);
                document.getElementById('carCount').textContent = count;

                const speedEl = document.getElementById('metricSpeed');
                const congEl = document.getElementById('metricCongestion');
                
                speedEl.className = 'metric' + (avgSpeed < 20 ? ' danger' : avgSpeed < 40 ? ' warning' : '');
                congEl.className = 'metric' + (congestion > 50 ? ' danger' : congestion > 25 ? ' warning' : '');

                const hours = Math.floor(this.gameTime / 60);
                const minutes = Math.floor(this.gameTime % 60);
                document.getElementById('timeDisplay').textContent = 
                    `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
                
                let phase = 'Low Traffic';
                if (hours >= 7 && hours <= 9) phase = 'Morning Rush';
                else if (hours >= 12 && hours <= 13) phase = 'Lunch Peak';
                else if (hours >= 17 && hours <= 19) phase = 'Evening Rush';
                else if (hours >= 22 || hours <= 5) phase = 'Night';
                document.getElementById('phaseDisplay').textContent = phase;
                
                // Night mode styling
                const timeContainer = document.getElementById('timeDisplayContainer');
                if (hours >= 20 || hours <= 5) {
                    timeContainer.classList.add('night');
                } else {
                    timeContainer.classList.remove('night');
                }
            }

            render() {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;
                
                const hour = Math.floor(this.gameTime / 60);
                const isNight = hour >= 20 || hour <= 5;

                // Clear with night/day gradient
                if (isNight) {
                    const grad = ctx.createLinearGradient(0, 0, 0, h);
                    grad.addColorStop(0, '#0a0a1a');
                    grad.addColorStop(1, '#1a1a3e');
                    ctx.fillStyle = grad;
                } else {
                    ctx.fillStyle = '#1a1f2e';
                }
                ctx.fillRect(0, 0, w, h);

                ctx.save();
                ctx.translate(w / 2 + this.camera.x, h / 2 + this.camera.y);
                ctx.scale(this.camera.zoom, this.camera.zoom);

                // Draw grid
                if (this.showGrid) {
                    ctx.strokeStyle = isNight ? '#1a1a3e' : '#21262d';
                    ctx.lineWidth = 1 / this.camera.zoom;
                    const gridRange = 50;
                    for (let i = -gridRange; i <= gridRange; i++) {
                        ctx.beginPath();
                        ctx.moveTo(i * this.gridSize, -gridRange * this.gridSize);
                        ctx.lineTo(i * this.gridSize, gridRange * this.gridSize);
                        ctx.stroke();
                        ctx.beginPath();
                        ctx.moveTo(-gridRange * this.gridSize, i * this.gridSize);
                        ctx.lineTo(gridRange * this.gridSize, i * this.gridSize);
                        ctx.stroke();
                    }
                }

                // Draw buildings with lights at night
                this.buildings.forEach(b => {
                    const x = b.x * this.gridSize;
                    const y = b.y * this.gridSize;
                    const bw = b.width * this.gridSize * 0.8;
                    const bh = b.height * this.gridSize * 0.8;
                    
                    ctx.fillStyle = b.type === 'residential' ? '#238636' : '#1f6feb';
                    ctx.fillRect(x - bw / 2, y - bh / 2, bw, bh);
                    
                    // Windows with lights at night
                    ctx.fillStyle = isNight ? (Math.random() > 0.3 ? '#facc15' : '#1a1a2e') : '#c9d1d9';
                    for (let wx = 0; wx < 2; wx++) {
                        for (let wy = 0; wy < 2; wy++) {
                            ctx.fillRect(
                                x - bw / 2 + 4 + wx * (bw / 2),
                                y - bh / 2 + 4 + wy * (bh / 2),
                                4, 4
                            );
                        }
                    }
                });

                // Draw roads with glow at night
                this.roads.forEach(road => {
                    const x = road.x * this.gridSize;
                    const y = road.y * this.gridSize;
                    
                    if (road.type === 'highway') {
                        ctx.fillStyle = '#30363d';
                        ctx.fillRect(x - this.gridSize / 2, y - this.gridSize / 2, this.gridSize, this.gridSize);
                        ctx.strokeStyle = '#f0883e';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.strokeRect(x - this.gridSize / 2 + 4, y - this.gridSize / 2 + 4, this.gridSize - 8, this.gridSize - 8);
                        ctx.setLineDash([]);
                    } else if (road.type === 'roundabout') {
                        ctx.fillStyle = '#30363d';
                        ctx.beginPath();
                        ctx.arc(x, y, this.gridSize / 2, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.strokeStyle = '#8b949e';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    } else if (road.type === 'intersection') {
                        ctx.fillStyle = isNight ? '#2a2f3e' : '#21262d';
                        ctx.fillRect(x - this.gridSize / 2, y - this.gridSize / 2, this.gridSize, this.gridSize);
                    } else {
                        ctx.fillStyle = isNight ? '#252a3d' : '#30363d';
                        ctx.fillRect(x - this.gridSize / 2, y - this.gridSize / 2, this.gridSize, this.gridSize);
                        
                        ctx.strokeStyle = isNight ? '#4a5568' : '#8b949e';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([4, 4]);
                        ctx.beginPath();
                        ctx.moveTo(x - this.gridSize / 2, y);
                        ctx.lineTo(x + this.gridSize / 2, y);
                        ctx.moveTo(x, y - this.gridSize / 2);
                        ctx.lineTo(x, y + this.gridSize / 2);
                        ctx.stroke();
                        ctx.setLineDash([]);
                    }
                });

                // Draw bus stops
                this.busStops.forEach(stop => {
                    const x = stop.x * this.gridSize;
                    const y = stop.y * this.gridSize;
                    ctx.fillStyle = '#f0883e';
                    ctx.beginPath();
                    ctx.arc(x, y, 6, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('üöå', x, y + 3);
                });

                // Draw metro lines
                this.metroLines.forEach(metro => {
                    const x = metro.x * this.gridSize;
                    const y = metro.y * this.gridSize;
                    ctx.fillStyle = '#a371f7';
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('M', x, y + 3);
                });

                // Draw traffic lights with glow
                this.trafficLights.forEach(light => {
                    const x = light.x * this.gridSize;
                    const y = light.y * this.gridSize;
                    
                    ctx.fillStyle = '#161b22';
                    ctx.beginPath();
                    ctx.arc(x, y, 8, 0, Math.PI * 2);
                    ctx.fill();
                    
                    const nsColor = light.state === 'NS' ? '#3fb950' : '#f85149';
                    const ewColor = light.state === 'EW' ? '#3fb950' : '#f85149';
                    
                    // Glow effect
                    if (isNight) {
                        ctx.shadowBlur = 10;
                        ctx.shadowColor = nsColor;
                    }
                    ctx.fillStyle = nsColor;
                    ctx.beginPath();
                    ctx.arc(x, y - 4, 3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    ctx.shadowColor = ewColor;
                    ctx.fillStyle = ewColor;
                    ctx.beginPath();
                    ctx.arc(x + 4, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                });

                // Draw events
                this.events.forEach(event => {
                    const x = event.x * this.gridSize;
                    const y = event.y * this.gridSize;
                    const icon = event.type === 'accident' ? 'üí•' : 'üöß';
                    
                    const pulse = Math.sin(performance.now() / 200) * 0.2 + 1;
                    ctx.font = `${16 * pulse}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText(icon, x, y + 5);
                });

                // Draw particles
                this.particles.forEach(p => {
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                });

                // Draw vehicles with headlights at night
                this.vehicles.forEach(v => {
                    const size = v.type === 'truck' ? 8 : v.type === 'bus' ? 10 : 6;
                    const color = v.color;
                    
                    // Headlights at night
                    if (isNight) {
                        ctx.save();
                        ctx.translate(v.x, v.y);
                        ctx.rotate(Math.atan2(v.vy, v.vx));
                        
                        const grad = ctx.createRadialGradient(size, 0, 0, size + 40, 0, 60);
                        grad.addColorStop(0, 'rgba(255, 255, 200, 0.4)');
                        grad.addColorStop(1, 'rgba(255, 255, 200, 0)');
                        ctx.fillStyle = grad;
                        ctx.beginPath();
                        ctx.moveTo(size, -5);
                        ctx.lineTo(size + 60, -20);
                        ctx.lineTo(size + 60, 20);
                        ctx.lineTo(size, 5);
                        ctx.fill();
                        
                        ctx.restore();
                    }
                    
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(v.x, v.y, size, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Brake lights
                    if (v.speed < 0.5) {
                        ctx.fillStyle = '#ff4444';
                        ctx.beginPath();
                        ctx.arc(v.x - v.vx * 2, v.y - v.vy * 2, size * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(v.x, v.y);
                    ctx.lineTo(v.x + v.vx * size * 1.5, v.y + v.vy * size * 1.5);
                    ctx.stroke();
                });

                // Draw hover cell
                if (this.hoveredCell) {
                    const x = this.hoveredCell.x * this.gridSize;
                    const y = this.hoveredCell.y * this.gridSize;
                    ctx.strokeStyle = '#58a6ff';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x - this.gridSize / 2, y - this.gridSize / 2, this.gridSize, this.gridSize);
                }

                ctx.restore();

                this.renderMinimap();
            }

            renderMinimap() {
                const ctx = this.minimapCtx;
                const w = this.minimap.width;
                const h = this.minimap.height;

                ctx.fillStyle = '#0d1117';
                ctx.fillRect(0, 0, w, h);

                const bounds = this.getWorldBounds();
                const scale = Math.min(w / (bounds.maxX - bounds.minX + 100), h / (bounds.maxY - bounds.minY + 100));
                const offsetX = (w - (bounds.maxX - bounds.minX) * scale) / 2 - bounds.minX * scale;
                const offsetY = (h - (bounds.maxY - bounds.minY) * scale) / 2 - bounds.minY * scale;

                ctx.fillStyle = '#30363d';
                this.roads.forEach(road => {
                    const x = road.x * this.gridSize * scale + offsetX;
                    const y = road.y * this.gridSize * scale + offsetY;
                    const size = this.gridSize * scale;
                    ctx.fillRect(x - size / 2, y - size / 2, size, size);
                });

                ctx.fillStyle = '#58a6ff';
                this.vehicles.forEach(v => {
                    const x = v.x * scale + offsetX;
                    const y = v.y * scale + offsetY;
                    ctx.beginPath();
                    ctx.arc(x, y, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                });

                const vpX = (-this.camera.x - this.canvas.width / 2) * scale / this.camera.zoom + offsetX;
                const vpY = (-this.camera.y - this.canvas.height / 2) * scale / this.camera.zoom + offsetY;
                const vpW = this.canvas.width * scale / this.camera.zoom;
                const vpH = this.canvas.height * scale / this.camera.zoom;
                ctx.strokeStyle = '#58a6ff';
                ctx.lineWidth = 1;
                ctx.strokeRect(vpX, vpY, vpW, vpH);
            }

            getWorldBounds() {
                let minX = 0, maxX = 0, minY = 0, maxY = 0;
                this.roads.forEach(r => {
                    minX = Math.min(minX, r.x * this.gridSize);
                    maxX = Math.max(maxX, r.x * this.gridSize);
                    minY = Math.min(minY, r.y * this.gridSize);
                    maxY = Math.max(maxY, r.y * this.gridSize);
                });
                return { minX, maxX, minY, maxY };
            }

            loop(currentTime) {
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;

                this.update(deltaTime);
                this.render();

                requestAnimationFrame((t) => this.loop(t));
            }

            logEvent(message, type = 'normal') {
                const log = document.getElementById('eventLog');
                const event = document.createElement('div');
                event.className = `event ${type}`;
                event.textContent = `[${this.formatTime()}] ${message}`;
                log.insertBefore(event, log.firstChild);
                
                while (log.children.length > 20) {
                    log.removeChild(log.lastChild);
                }
            }

            formatTime() {
                const hours = Math.floor(this.gameTime / 60);
                const minutes = Math.floor(this.gameTime % 60);
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            }

            showSaveModal() {
                const data = {
                    roads: this.roads,
                    trafficLights: this.trafficLights,
                    buildings: this.buildings,
                    busStops: this.busStops,
                    metroLines: this.metroLines,
                    gameTime: this.gameTime
                };
                const json = JSON.stringify(data);
                const encoded = btoa(json);
                document.getElementById('saveCode').value = encoded;
                document.getElementById('saveModal').classList.add('show');
            }

            showLoadModal() {
                document.getElementById('loadCode').value = '';
                document.getElementById('loadModal').classList.add('show');
            }

            loadCity() {
                try {
                    const encoded = document.getElementById('loadCode').value.trim();
                    const json = atob(encoded);
                    const data = JSON.parse(json);
                    
                    this.roads = data.roads || [];
                    this.trafficLights = data.trafficLights || [];
                    this.buildings = data.buildings || [];
                    this.busStops = data.busStops || [];
                    this.metroLines = data.metroLines || [];
                    this.gameTime = data.gameTime || 8 * 60;
                    this.vehicles = [];
                    this.events = [];
                    
                    document.getElementById('loadModal').classList.remove('show');
                    this.logEvent('City loaded successfully!', 'success');
                } catch (e) {
                    alert('Invalid save code!');
                }
            }

            clearCity() {
                if (confirm('Clear the entire city? This cannot be undone.')) {
                    this.roads = [];
                    this.trafficLights = [];
                    this.vehicles = [];
                    this.buildings = [];
                    this.events = [];
                    this.busStops = [];
                    this.metroLines = [];
                    this.logEvent('City cleared', 'warning');
                    this.audio.playCrashSound();
                }
            }
        }

        window.addEventListener('load', () => {
            new TrafficSimulator();
        });
    </script>
</body>
</html>
