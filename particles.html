<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Universe - Physics-Based Artificial Life</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Rajdhani:wght@300;400;500;600;700;800&family=Orbitron:wght@400;500;600;700;800;900&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --neon-blue: #00f5ff;
            --neon-pink: #ff00ff;
            --neon-green: #00ff88;
            --neon-purple: #b829dd;
            --neon-orange: #ff6b35;
            --neon-yellow: #ffff00;
            --dark-bg: #050508;
            --panel-bg: rgba(5, 5, 8, 0.98);
            --panel-border: rgba(0, 245, 255, 0.2);
        }
        
        body {
            background: var(--dark-bg);
            color: #fff;
            font-family: 'Rajdhani', sans-serif;
            overflow: hidden;
        }
        
        #canvas-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        
        .hud {
            position: fixed;
            z-index: 10;
            pointer-events: none;
        }
        
        .hud-top {
            top: 0;
            left: 0;
            right: 0;
            padding: 15px 25px;
            background: linear-gradient(180deg, rgba(0,0,0,0.95) 0%, transparent 100%);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 20px;
            flex-wrap: wrap;
            pointer-events: none;
        }
        
        .hud-top > * {
            pointer-events: auto;
        }
        
        .title-block {
            flex-shrink: 0;
            max-width: 300px;
        }
        
        .stats-container {
            flex: 1;
            min-width: 200px;
            max-width: 500px;
        }
        
        .hud-left {
            top: 100px;
            left: 20px;
            width: 320px;
            max-height: calc(100vh - 180px);
            overflow-y: auto;
            pointer-events: auto;
        }
        
        .hud-right {
            top: 100px;
            right: 20px;
            width: 320px;
            max-height: calc(100vh - 180px);
            overflow-y: auto;
            pointer-events: auto;
        }
        
        .hud-bottom {
            bottom: 0;
            left: 0;
            right: 0;
            padding: 15px;
            background: linear-gradient(0deg, rgba(0,0,0,0.95) 0%, transparent 100%);
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
            pointer-events: auto;
            max-height: 100px;
            overflow-y: auto;
        }
        
        .title-block h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: 24px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 4px;
            background: linear-gradient(90deg, var(--neon-blue), var(--neon-pink), var(--neon-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: titlePulse 3s ease-in-out infinite;
        }
        
        @keyframes titlePulse {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }
        
        .control-panel {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 12px;
            padding: 14px;
            backdrop-filter: blur(10px);
        }
        
        .panel-section {
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
        }
        
        .panel-section h3 {
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            color: var(--neon-blue);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 10px;
        }
        
        .btn {
            background: rgba(0,245,255,0.1);
            border: 1px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 8px 12px;
            border-radius: 6px;
            font-family: 'Orbitron', sans-serif;
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            pointer-events: all;
        }
        
        .btn:hover {
            background: rgba(0,245,255,0.2);
            transform: translateY(-2px);
        }
        
        .btn.active {
            background: var(--neon-green);
            border-color: var(--neon-green);
            color: #000;
        }
        
        .btn.primary {
            background: var(--neon-blue);
            border-color: var(--neon-blue);
            color: #000;
        }
        
        .btn.danger {
            background: rgba(255,51,51,0.2);
            border-color: var(--neon-red);
            color: var(--neon-red);
        }
        
        .btn-row {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        
        .stats-container {
            flex: 1;
            min-width: 200px;
            max-width: 400px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 6px;
        }
        
        .stat-box {
            background: var(--panel-bg);
            border: 1px solid var(--panel-border);
            border-radius: 6px;
            padding: 6px 8px;
            text-align: center;
        }
        
        .stat-box .value {
            font-family: 'Orbitron', monospace;
            font-size: 14px;
            font-weight: 700;
        }
        
        .stat-box .label {
            font-size: 8px;
            color: #888;
            text-transform: uppercase;
        }
        
        .slider-group {
            margin-bottom: 10px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #aaa;
            margin-bottom: 4px;
        }
        
        input[type="range"] {
            width: 100%;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--neon-blue);
            border-radius: 50%;
            cursor: pointer;
        }
        
        .particle-legend {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 10px;
            padding: 4px;
            background: rgba(255,255,255,0.03);
            border-radius: 4px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .chart-container {
            height: 70px;
            background: rgba(0,0,0,0.4);
            border-radius: 6px;
            padding: 8px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        select {
            background: rgba(0,0,0,0.5);
            border: 1px solid var(--panel-border);
            color: #fff;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            width: 100%;
        }
    </style>
</head>
<body>
    <div style="position: fixed; top: 20px; right: 20px; z-index: 1000; display:flex; gap:8px; align-items:center;">
        <button id="musicToggleBtn" onclick="toggleSpaceMusic()" style="background: rgba(10,10,15,0.9); border: 1px solid #b829dd; color: #b829dd; padding: 8px 16px; border-radius: 4px; font-size: 14px; font-family: 'Rajdhani', sans-serif; cursor:pointer; box-shadow: 0 2px 8px rgba(0,0,0,0.5);">üéµ Music</button>
        <input type="range" id="musicVolume" min="0" max="100" value="20" style="width:80px;cursor:pointer;" title="Music Volume" oninput="setSpaceMusicVolume(this.value)">
        <a href="/games" style="background: rgba(10,10,15,0.9); border: 1px solid #00f5ff; color: #00f5ff; padding: 8px 16px; border-radius: 4px; text-decoration: none; font-size: 14px; font-family: 'Rajdhani', sans-serif; display: inline-block; box-shadow: 0 2px 8px rgba(0,0,0,0.5);">üéÆ Games</a>
    </div>
    <!-- Keyboard help overlay -->
    <div id="keyHelp" style="display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(5,5,8,0.97);border:1px solid #00f5ff;border-radius:12px;padding:24px 32px;z-index:9999;min-width:280px;font-family:'Rajdhani',sans-serif;">
        <div style="color:#00f5ff;font-size:18px;font-weight:700;margin-bottom:14px;">‚å®Ô∏è Keyboard Controls</div>
        <div style="color:#aaa;line-height:2;font-size:14px;">
            <div><b style="color:#fff">Space</b> ‚Äì Play / Pause</div>
            <div><b style="color:#fff">R</b> ‚Äì Reset / Big Bang</div>
            <div><b style="color:#fff">C</b> ‚Äì Clear all</div>
            <div><b style="color:#fff">M</b> ‚Äì Toggle music</div>
            <div><b style="color:#fff">1-9</b> ‚Äì Load preset</div>
            <div><b style="color:#fff">H / O / N / F</b> ‚Äì Spawn H‚ÇÇ / O‚ÇÇ / Neutron / Photon</div>
            <div><b style="color:#fff">Esc / ?</b> ‚Äì Close help</div>
        </div>
        <button onclick="document.getElementById('keyHelp').style.display='none'" style="margin-top:14px;background:#00f5ff;border:none;color:#000;padding:8px 20px;border-radius:6px;cursor:pointer;font-family:'Rajdhani',sans-serif;font-weight:700;">Close</button>
    </div>
    
    <div id="canvas-container"></div>
    
    <div class="hud hud-top">
        <div class="title-block">
            <h1>‚öõÔ∏è Particle Universe</h1>
            <p style="font-size: 11px; color: #888; margin-top: 4px;">Physics-Based Artificial Life</p>
        </div>
        
        <div class="stats-container">
            <div class="stats-grid">
                <div class="stat-box">
                    <div class="value" id="particle-count">0</div>
                    <div class="label">Particles</div>
                </div>
                <div class="stat-box">
                    <div class="value" id="time-elapsed">0s</div>
                    <div class="label">Time</div>
                </div>
                <div class="stat-box">
                    <div class="value" id="bonds-formed">0</div>
                    <div class="label">Bonds</div>
                </div>
                <div class="stat-box">
                    <div class="value" id="reactions">0</div>
                    <div class="label">Reactions</div>
                </div>
                <div class="stat-box">
                    <div class="value" id="species-count">0</div>
                    <div class="label">Species</div>
                </div>
                <div class="stat-box">
                    <div class="value" id="energy-total">0</div>
                    <div class="label">Energy</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="hud hud-left">
        <div class="control-panel">
            <div class="panel-section">
                <h3>Simulation Control</h3>
                <div class="btn-row">
                    <button class="btn primary" id="play-btn" onclick="togglePlay()">‚ñ∂ PLAY</button>
                    <button class="btn" onclick="reset()">üîÑ RESET</button>
                    <button class="btn danger" onclick="clearAll()">üóë CLEAR</button>
                </div>
                <div class="btn-row" style="margin-top:8px;">
                    <button class="btn active" id="trail-btn" onclick="toggleTrails()" title="Toggle particle trails">‚ú® Trails</button>
                </div>
                
                <div class="slider-group" style="margin-top: 15px;">
                    <div class="slider-label">
                        <span>Speed</span>
                        <span id="speed-display">1x</span>
                    </div>
                    <input type="range" id="speed" min="0.1" max="5" step="0.1" value="1" onchange="updateSpeed(this.value)">
                </div>
                
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Gravity</span>
                        <span id="gravity-display">0.1</span>
                    </div>
                    <input type="range" id="gravity" min="0" max="1" step="0.05" value="0.1" onchange="updateGravity(this.value)">
                </div>
            </div>
            
            <div class="panel-section">
                <h3>Particle Types</h3>
                <div class="particle-legend" id="particle-legend"></div>
            </div>
            
            <div class="panel-section">
                <h3>Environment</h3>
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Temperature</span>
                        <span id="temp-display">300K</span>
                    </div>
                    <input type="range" id="temp" min="0" max="1000" value="300" onchange="updateTemp(this.value)">
                </div>
                
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Friction</span>
                        <span id="friction-display">0.99</span>
                    </div>
                    <input type="range" id="friction" min="0.90" max="1" step="0.001" value="0.99" onchange="updateFriction(this.value)">
                </div>
                
                <div class="slider-group">
                    <div class="slider-label">
                        <span>Boundary</span>
                    </div>
                    <select id="boundary" onchange="updateBoundary(this.value)">
                        <option value="bounce">Bounce</option>
                        <option value="wrap">Wrap</option>
                        <option value="none">None</option>
                    </select>
                </div>
            </div>
        </div>
    </div>
    
    <div class="hud hud-right">
        <div class="control-panel">
            <div class="panel-section">
                <h3>Spawn Particles</h3>
                <div class="btn-row">
                    <button class="btn" onclick="spawnBatch('hydrogen', 50)">H‚ÇÇ</button>
                    <button class="btn" onclick="spawnBatch('oxygen', 50)">O‚ÇÇ</button>
                    <button class="btn" onclick="spawnBatch('carbon', 30)">C</button>
                    <button class="btn" onclick="spawnBatch('helium', 30)">He</button>
                </div>
                <div class="btn-row" style="margin-top: 8px;">
                    <button class="btn" onclick="spawnBatch('iron', 20)">Fe</button>
                    <button class="btn" onclick="spawnBatch('gold', 15)">Au</button>
                    <button class="btn" onclick="spawnBatch('uranium', 10)">U</button>
                </div>
                <div class="btn-row" style="margin-top: 8px;">
                    <button class="btn" onclick="spawnBatch('photon', 20)">‚ö° Photon</button>
                    <button class="btn" onclick="spawnBatch('electron', 30)">‚ö° e‚Åª</button>
                    <button class="btn" onclick="spawnBatch('plasma', 20)">üî• Plasma</button>
                </div>
                <div class="btn-row" style="margin-top: 8px;">
                    <button class="btn" onclick="spawnBatch('darkmatter', 20)">üåë Dark</button>
                    <button class="btn pink" onclick="spawnBatch('life', 10)">ü¶† Life</button>
                </div>
            </div>
            
            <div class="panel-section">
                <h3>Universe Presets</h3>
                <div class="btn-row">
                    <button class="btn" onclick="loadPreset('bigbang')">üí• Big Bang</button>
                    <button class="btn" onclick="loadPreset('solarsystem')">‚òÄÔ∏è Solar</button>
                    <button class="btn" onclick="loadPreset('chemistry')">‚öóÔ∏è Chemistry</button>
                </div>
                <div class="btn-row" style="margin-top: 8px;">
                    <button class="btn" onclick="loadPreset('life')">üß¨ Primordial</button>
                    <button class="btn" onclick="loadPreset('plasma')">üî• Plasma</button>
                    <button class="btn" onclick="loadPreset('crystal')">üíé Crystal</button>
                </div>
                <div class="btn-row" style="margin-top: 8px;">
                    <button class="btn" onclick="loadPreset('magnetic')">üß≤ Magnetic</button>
                    <button class="btn" onclick="loadPreset('reactor')">‚ò¢Ô∏è Reactor</button>
                    <button class="btn" onclick="loadPreset('fusion')">‚öõÔ∏è Fusion</button>
                </div>
                <div class="btn-row" style="margin-top: 8px;">
                    <button class="btn" onclick="loadPreset('darkuniverse')">üåë Dark</button>
                    <button class="btn" onclick="loadPreset('goldrush')">üëë Gold</button>
                </div>
            </div>
            
            <div class="panel-section">
                <h3>Population History</h3>
                <div class="chart-container">
                    <canvas id="history-chart"></canvas>
                </div>
            </div>
        </div>
    </div>
    
    <div class="hud hud-bottom">
        <button class="btn" onclick="spawnParticle('hydrogen')">üíß H</button>
        <button class="btn" onclick="spawnParticle('oxygen')">üåä O</button>
        <button class="btn" onclick="spawnParticle('carbon')">‚ö´ C</button>
        <button class="btn" onclick="spawnParticle('helium')">üéà He</button>
        <button class="btn" onclick="spawnParticle('iron')">üß≤ Fe</button>
        <button class="btn" onclick="spawnParticle('gold')">üëë Au</button>
        <button class="btn" onclick="spawnParticle('uranium')">‚ò¢Ô∏è U</button>
        <button class="btn" onclick="spawnParticle('photon')">‚ö° Œ≥</button>
        <button class="btn" onclick="spawnParticle('electron')">‚ö° e‚Åª</button>
        <button class="btn" onclick="spawnParticle('plasma')">üî• Plasma</button>
        <button class="btn" onclick="spawnParticle('darkmatter')">üåë Dark</button>
        <button class="btn pink" onclick="spawnParticle('life')">ü¶† Life</button>
        <button class="btn" onclick="spawnParticle('virus')">üß¨ Virus</button>
        <button class="btn danger" onclick="spawnParticle('antimatter')">üí• Anti</button>
    </div>

    <script>
        // ============================================
        // PARTICLE UNIVERSE - Physics-Based ALife
        // ============================================
        
        const CONFIG = {
            maxParticles: 2000,
            timeScale: 1,
            gravity: 0.1,
            friction: 0.99,
            boundary: 'bounce',
            temperature: 300,
            worldSize: 100
        };
        
        // Particle Types with physics properties
        const PARTICLE_TYPES = {
            hydrogen: {
                mass: 1, radius: 0.5, color: 0xffffff, charge: 0.1,
                reactivity: 0.8, bonds: ['hydrogen', 'oxygen', 'carbon'], energy: 10,
                description: 'Basic building block'
            },
            oxygen: {
                mass: 16, radius: 1.2, color: 0xff4444, charge: -0.2,
                reactivity: 0.9, bonds: ['hydrogen', 'carbon', 'metal'], energy: 20,
                description: 'Reactive element'
            },
            carbon: {
                mass: 12, radius: 1.0, color: 0x444444, charge: 0,
                reactivity: 0.7, bonds: ['hydrogen', 'oxygen', 'nitrogen', 'carbon'], energy: 30,
                description: 'Life backbone'
            },
            nitrogen: {
                mass: 14, radius: 1.1, color: 0x4444ff, charge: -0.1,
                reactivity: 0.6, bonds: ['hydrogen', 'carbon'], energy: 25,
                description: 'Atmospheric gas'
            },
            metal: {
                mass: 50, radius: 2, color: 0x888888, charge: 0.3,
                reactivity: 0.3, bonds: ['metal', 'oxygen'], energy: 50,
                description: 'Heavy conductor'
            },
            photon: {
                mass: 0.1, radius: 0.3, color: 0xffff00, charge: 0,
                reactivity: 0, bonds: [], energy: 100, speed: 2,
                description: 'Light energy'
            },
            neutron: {
                mass: 1, radius: 0.6, color: 0x00ff00, charge: 0,
                reactivity: 0.1, bonds: [], energy: 5,
                description: 'Radiation'
            },
            life: {
                mass: 20, radius: 2.5, color: 0x00ff88, charge: 0.1,
                reactivity: 0.95, bonds: ['life'], energy: 100, metabolism: true,
                description: 'Self-replicating'
            },
            virus: {
                mass: 5, radius: 1.5, color: 0xff00ff, charge: -0.3,
                reactivity: 0.99, bonds: ['life'], energy: 50,
                description: 'Infects life'
            },
            antimatter: {
                mass: 1, radius: 0.8, color: 0x000000, charge: 0,
                reactivity: 1, bonds: [], energy: -1000, glow: 0xff0000,
                description: 'Destroys matter'
            },
            helium: {
                mass: 4, radius: 0.8, color: 0xffffdd, charge: 0,
                reactivity: 0.1, bonds: [], energy: 15,
                description: 'Inert gas'
            },
            iron: {
                mass: 56, radius: 2.2, color: 0x8b4513, charge: 0.4,
                reactivity: 0.2, bonds: ['iron', 'oxygen'], energy: 80, magnetic: true,
                description: 'Magnetic metal'
            },
            gold: {
                mass: 197, radius: 2.5, color: 0xffd700, charge: 0.5,
                reactivity: 0.05, bonds: [], energy: 200,
                description: 'Noble metal'
            },
            uranium: {
                mass: 238, radius: 3, color: 0x32cd32, charge: 0.6,
                reactivity: 0.4, bonds: [], energy: 500, radioactive: true,
                description: 'Radioactive'
            },
            darkmatter: {
                mass: 100, radius: 2, color: 0x4b0082, charge: 0,
                reactivity: 0, bonds: [], energy: 1000, dark: true,
                description: 'Invisible mass'
            },
            plasma: {
                mass: 0.5, radius: 1.5, color: 0xff6600, charge: 1,
                reactivity: 1, bonds: [], energy: 200, glowing: true,
                description: 'Ionized gas'
            },
            electron: {
                mass: 0.01, radius: 0.2, color: 0x00ffff, charge: -1,
                reactivity: 0.5, bonds: [], energy: 50, speed: 3,
                description: 'Negative charge'
            }
        };
        
        let particles = [];
        let bonds = [];
        let reactions = 0;
        let startTime = Date.now();
        let isPlaying = false;
        let scene, camera, renderer, controls;
        let particleMeshes = [];
        let trailLines = [];  // THREE.js trail line objects
        let history = [];
        const TRAIL_LENGTH = 18;  // positions stored per particle
        let showTrails = true;
        
        class Particle {
            constructor(type, x, y, z) {
                const props = PARTICLE_TYPES[type];
                this.type = type;
                this.x = x || (Math.random() - 0.5) * CONFIG.worldSize;
                this.y = y || (Math.random() - 0.5) * CONFIG.worldSize;
                this.z = z || (Math.random() - 0.5) * CONFIG.worldSize;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
                this.vz = (Math.random() - 0.5) * 2;
                this.mass = props.mass;
                this.radius = props.radius;
                this.charge = props.charge;
                this.energy = props.energy;
                this.age = 0;
                this.bonds = [];
                this.id = Math.random().toString(36).substr(2, 9);
                this.posHistory = [];  // for trails

                // Special properties
                if (type === 'photon') {
                    const speed = props.speed || 1;
                    this.vx *= speed;
                    this.vy *= speed;
                    this.vz *= speed;
                }
            }
            
            update() {
                // Apply forces
                this.vy -= CONFIG.gravity * 0.1;
                
                // Temperature = random motion
                const thermalEnergy = CONFIG.temperature / 300;
                this.vx += (Math.random() - 0.5) * 0.01 * thermalEnergy;
                this.vy += (Math.random() - 0.5) * 0.01 * thermalEnergy;
                this.vz += (Math.random() - 0.5) * 0.01 * thermalEnergy;
                
                // Friction
                this.vx *= CONFIG.friction;
                this.vy *= CONFIG.friction;
                this.vz *= CONFIG.friction;
                
                // Update position
                this.x += this.vx * CONFIG.timeScale;
                this.y += this.vy * CONFIG.timeScale;
                this.z += this.vz * CONFIG.timeScale;
                
                // Boundaries
                const limit = CONFIG.worldSize / 2;
                if (CONFIG.boundary === 'bounce') {
                    if (Math.abs(this.x) > limit) {
                        this.x = Math.sign(this.x) * limit;
                        this.vx *= -0.8;
                    }
                    if (Math.abs(this.y) > limit) {
                        this.y = Math.sign(this.y) * limit;
                        this.vy *= -0.8;
                    }
                    if (Math.abs(this.z) > limit) {
                        this.z = Math.sign(this.z) * limit;
                        this.vz *= -0.8;
                    }
                } else if (CONFIG.boundary === 'wrap') {
                    if (Math.abs(this.x) > limit) this.x = -Math.sign(this.x) * limit;
                    if (Math.abs(this.y) > limit) this.y = -Math.sign(this.y) * limit;
                    if (Math.abs(this.z) > limit) this.z = -Math.sign(this.z) * limit;
                }
                
                this.age++;
                
                // Life metabolism
                if (this.type === 'life') {
                    this.energy -= 0.1;
                    if (this.energy <= 0) return false; // Die
                    
                    // Reproduce if healthy
                    if (this.energy > 150 && Math.random() < 0.001) {
                        this.energy -= 50;
                        return 'reproduce';
                    }
                }
                
                // Photon decay
                if (this.type === 'photon' && Math.random() < 0.01) {
                    return false;
                }
                
                return true;
            }
        }
        
        function init() {
            setupThreeJS();
            updateLegend();
            render();
            updateStats();
        }
        
        function setupThreeJS() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050508);
            scene.fog = new THREE.FogExp2(0x050508, 0.008);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(80, 60, 80);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            container.appendChild(renderer.domElement);
            
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            scene.add(directionalLight);
            
            // Boundary box
            const boxGeo = new THREE.BoxGeometry(CONFIG.worldSize, CONFIG.worldSize, CONFIG.worldSize);
            const boxEdges = new THREE.EdgesGeometry(boxGeo);
            const boxMat = new THREE.LineBasicMaterial({ color: 0x00f5ff, transparent: true, opacity: 0.1 });
            const box = new THREE.LineSegments(boxEdges, boxMat);
            scene.add(box);
            
            window.addEventListener('resize', onWindowResize);
        }
        
        function spawnParticle(type, x, y, z) {
            if (particles.length >= CONFIG.maxParticles) return;
            
            const p = new Particle(type, x, y, z);
            particles.push(p);
            
            // Create mesh
            const props = PARTICLE_TYPES[type];
            const geometry = new THREE.SphereGeometry(props.radius, 16, 16);
            const material = new THREE.MeshPhongMaterial({
                color: props.color,
                emissive: props.glow || props.color,
                emissiveIntensity: 0.3
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(p.x, p.y, p.z);
            scene.add(mesh);
            particleMeshes.push({ mesh, particle: p });

            // Create trail line using BufferGeometry
            const trailPositions = new Float32Array(TRAIL_LENGTH * 3);
            for (let t = 0; t < TRAIL_LENGTH * 3; t++) trailPositions[t] = p.x;
            const trailGeo = new THREE.BufferGeometry();
            trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            // Draw only first segment initially
            trailGeo.setDrawRange(0, 1);
            const trailColor = props.glow || props.color;
            const trailMat = new THREE.LineBasicMaterial({
                color: trailColor,
                transparent: true,
                opacity: 0.55,
                linewidth: 1
            });
            const trailLine = new THREE.Line(trailGeo, trailMat);
            scene.add(trailLine);
            trailLines.push({ line: trailLine, geo: trailGeo, particle: p, positions: trailPositions });

            updateStats();
        }
        
        function spawnBatch(type, count) {
            for (let i = 0; i < count; i++) {
                spawnParticle(type);
            }
        }
        
        function updatePhysics() {
            const toRemove = [];
            const toAdd = [];
            
            // Update particles
            for (let i = 0; i < particles.length; i++) {
                const p = particles[i];
                const result = p.update();
                
                if (result === false) {
                    toRemove.push(i);
                } else if (result === 'reproduce') {
                    toAdd.push(new Particle(p.type, p.x + (Math.random() - 0.5) * 5, 
                                           p.y + (Math.random() - 0.5) * 5, 
                                           p.z + (Math.random() - 0.5) * 5));
                }
            }
            
            // Check collisions and reactions
            for (let i = 0; i < particles.length; i++) {
                for (let j = i + 1; j < particles.length; j++) {
                    const p1 = particles[i];
                    const p2 = particles[j];
                    
                    const dx = p2.x - p1.x;
                    const dy = p2.y - p1.y;
                    const dz = p2.z - p1.z;
                    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    const minDist = p1.radius + p2.radius;
                    
                    if (dist < minDist) {
                        handleCollision(p1, p2, i, j, toRemove, toAdd);
                    }
                    
                    // Electrostatic forces
                    if (dist < 20 && dist > minDist) {
                        const force = (p1.charge * p2.charge) / (dist * dist) * 10;
                        const fx = (dx / dist) * force;
                        const fy = (dy / dist) * force;
                        const fz = (dz / dist) * force;
                        
                        p1.vx -= fx / p1.mass;
                        p1.vy -= fy / p1.mass;
                        p1.vz -= fz / p1.mass;
                        p2.vx += fx / p2.mass;
                        p2.vy += fy / p2.mass;
                        p2.vz += fz / p2.mass;
                    }
                    
                    // Magnetic forces (dipole-dipole approximation)
                    if (p1.magnetic && p2.magnetic && dist < 30) {
                        const magneticForce = 50 / (dist * dist);
                        const fx = (dx / dist) * magneticForce;
                        const fy = (dy / dist) * magneticForce;
                        const fz = (dz / dist) * magneticForce;
                        
                        p1.vx += fx / p1.mass;
                        p1.vy += fy / p1.mass;
                        p1.vz += fz / p1.mass;
                        p2.vx -= fx / p2.mass;
                        p2.vy -= fy / p2.mass;
                        p2.vz -= fz / p2.mass;
                    }
                    
                    // Dark matter gravity (only affects dark matter)
                    if (p1.dark && p2.dark && dist < 50) {
                        const darkForce = 100 / (dist * dist);
                        const fx = (dx / dist) * darkForce;
                        const fy = (dy / dist) * darkForce;
                        const fz = (dz / dist) * darkForce;
                        
                        p1.vx -= fx / p1.mass;
                        p1.vy -= fy / p1.mass;
                        p1.vz -= fz / p1.mass;
                        p2.vx += fx / p2.mass;
                        p2.vy += fy / p2.mass;
                        p2.vz += fz / p2.mass;
                    }
                    
                    // Radioactive decay effects
                    if (p1.radioactive && dist < 10) {
                        p2.energy -= 0.5;
                    }
                    if (p2.radioactive && dist < 10) {
                        p1.energy -= 0.5;
                    }
                }
            }
            
            // Remove dead particles (deduplicate indices first)
            const uniqueRemove = [...new Set(toRemove)].sort((a, b) => b - a);
            for (const idx of uniqueRemove) {
                if (idx < 0 || idx >= particles.length) continue;
                if (particleMeshes[idx]) {
                    scene.remove(particleMeshes[idx].mesh);
                    particleMeshes[idx].mesh.geometry.dispose();
                    particleMeshes[idx].mesh.material.dispose();
                }
                if (trailLines[idx]) {
                    scene.remove(trailLines[idx].line);
                    trailLines[idx].geo.dispose();
                    trailLines[idx].line.material.dispose();
                }
                particles.splice(idx, 1);
                particleMeshes.splice(idx, 1);
                trailLines.splice(idx, 1);
            }
            
            // Add new particles (reuse spawnParticle to also create trail)
            for (const p of toAdd) {
                if (particles.length < CONFIG.maxParticles) {
                    spawnParticle(p.type, p.x, p.y, p.z);
                    // Copy velocity from the pre-built particle
                    const newP = particles[particles.length - 1];
                    newP.vx = p.vx; newP.vy = p.vy; newP.vz = p.vz;
                    newP.energy = p.energy;
                }
            }
        }
        
        function handleCollision(p1, p2, i, j, toRemove, toAdd) {
            // Antimatter annihilation
            if ((p1.type === 'antimatter' || p2.type === 'antimatter') && 
                !(p1.type === 'antimatter' && p2.type === 'antimatter')) {
                toRemove.push(i);
                toRemove.push(j);
                reactions++;
                
                // Release energy as photons
                for (let k = 0; k < 10; k++) {
                    toAdd.push(new Particle('photon', p1.x, p1.y, p1.z));
                }
                return;
            }
            
            // Virus infects life
            if ((p1.type === 'virus' && p2.type === 'life') ||
                (p2.type === 'virus' && p1.type === 'life')) {
                const life = p1.type === 'life' ? p1 : p2;
                const virus = p1.type === 'virus' ? p1 : p2;
                
                life.energy -= 20;
                virus.energy += 10;
                
                if (life.energy <= 0) {
                    toRemove.push(particles.indexOf(life));
                    // Virus reproduces
                    if (Math.random() < 0.5) {
                        toAdd.push(new Particle('virus', virus.x, virus.y, virus.z));
                    }
                }
                return;
            }
            
            // Uranium fission
            if ((p1.type === 'uranium' || p2.type === 'uranium') &&
                (p1.type === 'neutron' || p2.type === 'neutron')) {
                const u = p1.type === 'uranium' ? p1 : p2;
                const n = p1.type === 'neutron' ? p1 : p2;
                
                toRemove.push(particles.indexOf(u));
                toRemove.push(particles.indexOf(n));
                reactions++;
                
                // Fission products
                for (let k = 0; k < 3; k++) {
                    toAdd.push(new Particle('iron', u.x + (Math.random() - 0.5) * 5, 
                                           u.y + (Math.random() - 0.5) * 5, 
                                           u.z + (Math.random() - 0.5) * 5));
                }
                // Release more neutrons
                for (let k = 0; k < 3; k++) {
                    toAdd.push(new Particle('neutron', u.x, u.y, u.z));
                }
                // Energy
                for (let k = 0; k < 5; k++) {
                    toAdd.push(new Particle('photon', u.x, u.y, u.z));
                }
                return;
            }
            
            // Plasma fusion
            if (p1.type === 'plasma' && p2.type === 'plasma') {
                if (Math.random() < 0.1) {
                    toRemove.push(i);
                    toRemove.push(j);
                    reactions++;
                    
                    toAdd.push(new Particle('helium', p1.x, p1.y, p1.z));
                    // Release energy
                    for (let k = 0; k < 5; k++) {
                        toAdd.push(new Particle('photon', p1.x, p1.y, p1.z));
                    }
                    return;
                }
            }
            
            // Gold-electron interaction (conduction)
            if ((p1.type === 'gold' && p2.type === 'electron') ||
                (p2.type === 'gold' && p1.type === 'electron')) {
                const electron = p1.type === 'electron' ? p1 : p2;
                // Electron bounces off with high energy
                electron.vx *= 1.5;
                electron.vy *= 1.5;
                electron.vz *= 1.5;
            }
            
            // Life eats other particles
            if (p1.type === 'life' || p2.type === 'life') {
                const life = p1.type === 'life' ? p1 : p2;
                const food = p1.type === 'life' ? p2 : p1;
                
                if (['hydrogen', 'oxygen', 'carbon', 'photon'].includes(food.type)) {
                    life.energy += food.energy * 0.5;
                    toRemove.push(particles.indexOf(food));
                    return;
                }
            }
            
            // Bounce
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            const dz = p2.z - p1.z;
            const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
            
            const nx = dx / dist;
            const ny = dy / dist;
            const nz = dz / dist;
            
            const dvx = p2.vx - p1.vx;
            const dvy = p2.vy - p1.vy;
            const dvz = p2.vz - p1.vz;
            
            const velAlongNormal = dvx * nx + dvy * ny + dvz * nz;
            
            if (velAlongNormal > 0) return;
            
            const e = 0.8; // Restitution
            const impulse = -(1 + e) * velAlongNormal / (1/p1.mass + 1/p2.mass);
            
            p1.vx -= impulse * nx / p1.mass;
            p1.vy -= impulse * ny / p1.mass;
            p1.vz -= impulse * nz / p1.mass;
            p2.vx += impulse * nx / p2.mass;
            p2.vy += impulse * ny / p2.mass;
            p2.vz += impulse * nz / p2.mass;
            
            // Separate particles
            const overlap = (p1.radius + p2.radius - dist) / 2;
            p1.x -= nx * overlap;
            p1.y -= ny * overlap;
            p1.z -= nz * overlap;
            p2.x += nx * overlap;
            p2.y += ny * overlap;
            p2.z += nz * overlap;
        }
        
        function updateVisuals() {
            const time = Date.now() * 0.001;

            for (let i = 0; i < particleMeshes.length; i++) {
                const pm = particleMeshes[i];
                pm.mesh.position.set(pm.particle.x, pm.particle.y, pm.particle.z);

                // Scale based on energy
                const scale = 0.8 + (pm.particle.energy / 200);

                // Pulsing effect for certain particles
                if (pm.particle.type === 'life' || pm.particle.type === 'plasma') {
                    const pulse = 1 + Math.sin(time * 3 + i) * 0.15;
                    pm.mesh.scale.setScalar(scale * pulse);
                } else if (pm.particle.type === 'uranium') {
                    const pulse = 1 + Math.sin(time * 10 + i) * 0.08;
                    pm.mesh.scale.setScalar(scale * pulse);
                } else {
                    pm.mesh.scale.setScalar(Math.max(0.1, scale));
                }

                // Enhanced glowing effect
                if (pm.particle.type === 'photon' || pm.particle.type === 'plasma') {
                    pm.mesh.material.emissiveIntensity = 0.6 + Math.sin(time * 6 + i) * 0.4;
                } else if (pm.particle.type === 'life') {
                    pm.mesh.material.emissiveIntensity = 0.3 + Math.sin(time * 2 + i) * 0.2;
                } else if (pm.particle.type === 'uranium') {
                    pm.mesh.material.emissiveIntensity = 0.2 + Math.sin(time * 8 + i) * 0.15;
                } else {
                    pm.mesh.material.emissiveIntensity = 0.15;
                }

                // Dark matter: semi-visible shimmer
                if (pm.particle.type === 'darkmatter') {
                    pm.mesh.material.opacity = 0.25 + Math.sin(time * 1.5 + i) * 0.15;
                    pm.mesh.material.transparent = true;
                }
            }

            // Update trails
            if (showTrails) {
                for (let i = 0; i < trailLines.length; i++) {
                    const tl = trailLines[i];
                    const p = tl.particle;

                    // Push current position into history
                    p.posHistory.push(p.x, p.y, p.z);
                    const maxLen = TRAIL_LENGTH * 3;
                    if (p.posHistory.length > maxLen) {
                        p.posHistory.splice(0, p.posHistory.length - maxLen);
                    }

                    // Write history into buffer (newest = index 0, oldest = last)
                    const histLen = p.posHistory.length / 3;
                    for (let j = 0; j < histLen; j++) {
                        // Reverse so newest is first for rendering from head to tail
                        const srcIdx = (histLen - 1 - j) * 3;
                        const dstIdx = j * 3;
                        tl.positions[dstIdx]     = p.posHistory[srcIdx];
                        tl.positions[dstIdx + 1] = p.posHistory[srcIdx + 1];
                        tl.positions[dstIdx + 2] = p.posHistory[srcIdx + 2];
                    }
                    tl.geo.attributes.position.needsUpdate = true;
                    tl.geo.setDrawRange(0, Math.max(2, histLen));

                    // Fade opacity based on particle energy/speed
                    const speed = Math.sqrt(p.vx * p.vx + p.vy * p.vy + p.vz * p.vz);
                    const baseOpacity = p.type === 'photon' ? 0.8 :
                                        p.type === 'plasma' ? 0.65 :
                                        p.type === 'electron' ? 0.7 :
                                        p.type === 'life' ? 0.5 :
                                        p.type === 'antimatter' ? 0.0 : 0.35;
                    tl.line.material.opacity = Math.min(0.85, baseOpacity + speed * 0.05);
                    tl.line.visible = showTrails && histLen > 1;
                }
            } else {
                trailLines.forEach(tl => { tl.line.visible = false; });
            }
        }
        
        function render() {
            requestAnimationFrame(render);
            
            if (isPlaying) {
                updatePhysics();
                updateVisuals();
                
                if (Date.now() % 30 === 0) {
                    updateStats();
                }
            }
            
            controls.update();
            renderer.render(scene, camera);
        }
        
        function updateStats() {
            document.getElementById('particle-count').textContent = particles.length;
            document.getElementById('time-elapsed').textContent = 
                Math.floor((Date.now() - startTime) / 1000) + 's';
            document.getElementById('reactions').textContent = reactions;
            
            const totalEnergy = particles.reduce((sum, p) => sum + p.energy, 0);
            document.getElementById('energy-total').textContent = Math.floor(totalEnergy);
            
            // Count species
            const types = {};
            particles.forEach(p => types[p.type] = (types[p.type] || 0) + 1);
            document.getElementById('species-count').textContent = Object.keys(types).length;
            
            // Update history chart
            history.push(particles.length);
            if (history.length > 100) history.shift();
            drawHistoryChart();
        }
        
        function drawHistoryChart() {
            const canvas = document.getElementById('history-chart');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (history.length < 2) return;
            
            const max = Math.max(...history, 100);
            
            ctx.beginPath();
            ctx.strokeStyle = '#00f5ff';
            ctx.lineWidth = 2;
            
            history.forEach((val, i) => {
                const x = (i / (history.length - 1)) * canvas.width;
                const y = canvas.height - (val / max) * canvas.height;
                
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            });
            
            ctx.stroke();
        }
        
        function updateLegend() {
            const container = document.getElementById('particle-legend');
            let html = '';
            
            for (const [name, props] of Object.entries(PARTICLE_TYPES)) {
                const hexColor = '#' + props.color.toString(16).padStart(6, '0');
                html += `
                    <div class="legend-item">
                        <div class="legend-color" style="background: ${hexColor};"></div>
                        <span>${name.charAt(0).toUpperCase() + name.slice(1)}</span>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }
        
        // Controls
        function togglePlay() {
            isPlaying = !isPlaying;
            document.getElementById('play-btn').textContent = isPlaying ? '‚è∏ PAUSE' : '‚ñ∂ PLAY';
            document.getElementById('play-btn').classList.toggle('active', isPlaying);
        }
        
        function reset() {
            clearAll();
            loadPreset('bigbang');
        }
        
        function clearAll() {
            particleMeshes.forEach(pm => {
                scene.remove(pm.mesh);
                pm.mesh.geometry.dispose();
                pm.mesh.material.dispose();
            });
            trailLines.forEach(tl => {
                scene.remove(tl.line);
                tl.geo.dispose();
                tl.line.material.dispose();
            });
            particles = [];
            particleMeshes = [];
            trailLines = [];
            bonds = [];
            reactions = 0;
            history = [];
            updateStats();
        }
        
        function updateSpeed(val) {
            CONFIG.timeScale = parseFloat(val);
            document.getElementById('speed-display').textContent = val + 'x';
        }
        
        function updateGravity(val) {
            CONFIG.gravity = parseFloat(val);
            document.getElementById('gravity-display').textContent = val;
        }
        
        function updateTemp(val) {
            CONFIG.temperature = parseInt(val);
            document.getElementById('temp-display').textContent = val + 'K';
        }
        
        function updateFriction(val) {
            CONFIG.friction = parseFloat(val);
            document.getElementById('friction-display').textContent = val;
        }
        
        function updateBoundary(val) {
            CONFIG.boundary = val;
        }
        
        function loadPreset(name) {
            clearAll();
            
            switch(name) {
                case 'bigbang':
                    spawnBatch('hydrogen', 300);
                    spawnBatch('helium', 100);
                    particles.forEach(p => {
                        p.vx *= 5;
                        p.vy *= 5;
                        p.vz *= 5;
                    });
                    break;
                    
                case 'solarsystem':
                    // Central star
                    for (let i = 0; i < 50; i++) {
                        spawnParticle('photon', 0, 0, 0);
                    }
                    // Planets
                    for (let i = 0; i < 5; i++) {
                        const angle = (i / 5) * Math.PI * 2;
                        const dist = 20 + i * 15;
                        const x = Math.cos(angle) * dist;
                        const z = Math.sin(angle) * dist;
                        spawnParticle('metal', x, 0, z);
                        // Give orbital velocity
                        const planet = particles[particles.length - 1];
                        planet.vx = -Math.sin(angle) * 2;
                        planet.vz = Math.cos(angle) * 2;
                    }
                    break;
                    
                case 'chemistry':
                    spawnBatch('hydrogen', 200);
                    spawnBatch('oxygen', 100);
                    spawnBatch('carbon', 80);
                    spawnBatch('nitrogen', 50);
                    break;
                    
                case 'life':
                    spawnBatch('life', 20);
                    spawnBatch('hydrogen', 200);
                    spawnBatch('oxygen', 100);
                    spawnBatch('photon', 50);
                    break;
                    
                case 'plasma':
                    spawnBatch('photon', 300);
                    CONFIG.temperature = 800;
                    break;
                    
                case 'crystal':
                    for (let x = -20; x <= 20; x += 4) {
                        for (let y = -20; y <= 20; y += 4) {
                            for (let z = -20; z <= 20; z += 4) {
                                spawnParticle('metal', x, y, z);
                            }
                        }
                    }
                    break;
                    
                case 'magnetic':
                    spawnBatch('iron', 100);
                    spawnBatch('electron', 50);
                    break;
                    
                case 'reactor':
                    spawnBatch('uranium', 20);
                    spawnBatch('neutron', 100);
                    break;
                    
                case 'darkuniverse':
                    spawnBatch('darkmatter', 200);
                    spawnBatch('hydrogen', 100);
                    break;
                    
                case 'fusion':
                    spawnBatch('plasma', 300);
                    CONFIG.temperature = 1000;
                    break;
                    
                case 'goldrush':
                    spawnBatch('gold', 50);
                    spawnBatch('electron', 100);
                    break;
            }
            
            updateStats();
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ================================================================
        // SPACE AMBIENT MUSIC & SOUND FX SYSTEM
        // ================================================================
        const SpaceAudio = {
            ctx: null,
            masterGain: null,
            ambientGain: null,
            sfxGain: null,
            isPlaying: false,
            isMuted: false,
            volume: 0.20,
            nodes: [],
            reactionCooldown: 0,

            init() {
                if (this.ctx) return;
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                if (this.ctx.state === 'suspended') this.ctx.resume();

                const comp = this.ctx.createDynamicsCompressor();
                comp.threshold.value = -20; comp.ratio.value = 4;
                comp.attack.value = 0.005; comp.release.value = 0.3;

                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = this.volume;
                this.ambientGain = this.ctx.createGain();
                this.ambientGain.gain.value = 0.65;
                this.sfxGain = this.ctx.createGain();
                this.sfxGain.gain.value = 0.35;

                this.ambientGain.connect(comp);
                this.sfxGain.connect(comp);
                comp.connect(this.masterGain);
                this.masterGain.connect(this.ctx.destination);
            },

            _makeNoise(sr, seconds, type='pink') {
                const buf = this.ctx.createBuffer(1, Math.floor(sr * seconds), sr);
                const d = buf.getChannelData(0);
                let b0=0,b1=0,b2=0,b3=0,b4=0,b5=0,b6=0;
                for (let i = 0; i < d.length; i++) {
                    const w = Math.random() * 2 - 1;
                    if (type === 'pink') {
                        b0 = 0.99886*b0 + w*0.0555179; b1 = 0.99332*b1 + w*0.0750759;
                        b2 = 0.96900*b2 + w*0.1538520; b3 = 0.86650*b3 + w*0.3104856;
                        b4 = 0.55000*b4 + w*0.5329522; b5 = -0.7616*b5 - w*0.0168980;
                        d[i] = (b0+b1+b2+b3+b4+b5+b6+w*0.5362) * 0.11;
                        b6 = w * 0.115926;
                    } else {
                        d[i] = w;
                    }
                }
                return buf;
            },

            startAmbient() {
                if (!this.ctx) return;
                const sr = this.ctx.sampleRate;

                // Deep space drone - ultra-low frequencies
                const cosmicFreqs = [27.5, 36.7, 41.2, 55.0]; // A0, D1, E1, A1
                cosmicFreqs.forEach((f, i) => {
                    const osc = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    osc.type = (i % 2 === 0) ? 'sine' : 'triangle';
                    osc.frequency.value = f;
                    osc.detune.value = (Math.random() - 0.5) * 12;
                    g.gain.setValueAtTime(0, this.ctx.currentTime);
                    g.gain.linearRampToValueAtTime(0.012, this.ctx.currentTime + 5);
                    // Slow pulse
                    const lfo = this.ctx.createOscillator();
                    lfo.type = 'sine'; lfo.frequency.value = 0.02 + i * 0.008;
                    const lfoG = this.ctx.createGain(); lfoG.gain.value = 0.005;
                    lfo.connect(lfoG); lfoG.connect(g.gain);
                    lfo.start(); osc.connect(g); g.connect(this.ambientGain); osc.start();
                    this.nodes.push(osc, lfo);
                });

                // Cosmic shimmer - mid-high ethereal tones
                [220, 330, 440, 660].forEach((f, i) => {
                    const osc = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = f * (1 + (Math.random() - 0.5) * 0.01);
                    // Slow attack
                    g.gain.setValueAtTime(0, this.ctx.currentTime);
                    g.gain.linearRampToValueAtTime(0.006, this.ctx.currentTime + 8);
                    // Tremolo
                    const lfo = this.ctx.createOscillator();
                    lfo.type = 'sine'; lfo.frequency.value = 0.08 + i * 0.03;
                    const lfoG = this.ctx.createGain(); lfoG.gain.value = 0.003;
                    lfo.connect(lfoG); lfoG.connect(g.gain);
                    lfo.start(); osc.connect(g); g.connect(this.ambientGain); osc.start();
                    this.nodes.push(osc, lfo);
                });

                // Space hiss - pink noise filtered to high frequencies
                const noiseBuf = this._makeNoise(sr, 5, 'pink');
                const noiseSrc = this.ctx.createBufferSource();
                noiseSrc.buffer = noiseBuf; noiseSrc.loop = true;
                const hpf = this.ctx.createBiquadFilter();
                hpf.type = 'highpass'; hpf.frequency.value = 8000; hpf.Q.value = 0.5;
                const noiseG = this.ctx.createGain();
                noiseG.gain.setValueAtTime(0, this.ctx.currentTime);
                noiseG.gain.linearRampToValueAtTime(0.018, this.ctx.currentTime + 3);
                noiseSrc.connect(hpf); hpf.connect(noiseG); noiseG.connect(this.ambientGain);
                noiseSrc.start();
                this.nodes.push(noiseSrc);

                // Evolving chord sequence - pentatonic space
                this._scheduleSpaceChords();
            },

            _scheduleSpaceChords() {
                if (!this.isPlaying) return;
                const spaceChords = [
                    [55.0, 82.4, 110.0, 164.8],   // A1 chord
                    [65.4, 98.0, 130.8, 196.0],   // C2 chord
                    [49.0, 73.4, 98.0, 146.8],    // G1 chord
                    [43.7, 65.4, 87.3, 130.8]     // F1 chord
                ];
                let idx = 0;
                const playNextChord = () => {
                    if (!this.isPlaying || this.isMuted) { setTimeout(playNextChord, 8000); return; }
                    const chord = spaceChords[idx % spaceChords.length];
                    idx++;
                    chord.forEach((f, i) => {
                        const osc = this.ctx.createOscillator();
                        const g = this.ctx.createGain();
                        osc.type = 'sine';
                        osc.frequency.value = f;
                        osc.detune.value = (Math.random() - 0.5) * 5;
                        const t = this.ctx.currentTime;
                        g.gain.setValueAtTime(0, t);
                        g.gain.linearRampToValueAtTime(0.018, t + 2);
                        g.gain.setValueAtTime(0.018, t + 5);
                        g.gain.linearRampToValueAtTime(0, t + 7.5);
                        osc.connect(g); g.connect(this.ambientGain);
                        osc.start(t); osc.stop(t + 8);
                    });
                    setTimeout(playNextChord, 7800);
                };
                setTimeout(playNextChord, 1000);
            },

            // --- Sound Effects ---
            playAnnihilation(x, y) {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                // Explosive crack
                const sr = this.ctx.sampleRate;
                const buf = this.ctx.createBuffer(1, Math.floor(sr * 0.4), sr);
                const d = buf.getChannelData(0);
                for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (d.length * 0.3));
                const src = this.ctx.createBufferSource(); src.buffer = buf;
                const lpf = this.ctx.createBiquadFilter(); lpf.type = 'lowpass'; lpf.frequency.value = 1000;
                const g = this.ctx.createGain(); g.gain.value = 0.06;
                src.connect(lpf); lpf.connect(g); g.connect(this.sfxGain);
                src.start(t);
                // High whine
                const osc = this.ctx.createOscillator(); const og = this.ctx.createGain();
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(800, t);
                osc.frequency.exponentialRampToValueAtTime(50, t + 0.4);
                og.gain.setValueAtTime(0.04, t); og.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
                osc.connect(og); og.connect(this.sfxGain); osc.start(t); osc.stop(t + 0.5);
            },

            playFission() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                // Low boom
                const osc = this.ctx.createOscillator(); const g = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(120, t); osc.frequency.exponentialRampToValueAtTime(30, t + 0.3);
                g.gain.setValueAtTime(0.05, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.35);
                osc.connect(g); g.connect(this.sfxGain); osc.start(t); osc.stop(t + 0.4);
                // Crackle
                const sr = this.ctx.sampleRate;
                const buf = this.ctx.createBuffer(1, Math.floor(sr * 0.2), sr);
                const d = buf.getChannelData(0);
                for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * (1 - i / d.length);
                const src = this.ctx.createBufferSource(); src.buffer = buf;
                const hpf = this.ctx.createBiquadFilter(); hpf.type = 'highpass'; hpf.frequency.value = 2000;
                const g2 = this.ctx.createGain(); g2.gain.value = 0.035;
                src.connect(hpf); hpf.connect(g2); g2.connect(this.sfxGain); src.start(t);
            },

            playFusion() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                const osc = this.ctx.createOscillator(); const g = this.ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200, t); osc.frequency.linearRampToValueAtTime(600, t + 0.2);
                osc.frequency.exponentialRampToValueAtTime(100, t + 0.6);
                g.gain.setValueAtTime(0.04, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.7);
                osc.connect(g); g.connect(this.sfxGain); osc.start(t); osc.stop(t + 0.75);
            },

            playBirth() {
                if (!this.ctx) return;
                const t = this.ctx.currentTime;
                [0, 0.06, 0.12].forEach((dt, i) => {
                    const osc = this.ctx.createOscillator(); const g = this.ctx.createGain();
                    osc.type = 'sine'; osc.frequency.value = 600 + i * 200;
                    g.gain.setValueAtTime(0.022, t + dt); g.gain.exponentialRampToValueAtTime(0.001, t + dt + 0.14);
                    osc.connect(g); g.connect(this.sfxGain); osc.start(t + dt); osc.stop(t + dt + 0.15);
                });
            },

            onReaction(type) {
                this.reactionCooldown--;
                if (this.reactionCooldown > 0) return;
                if (!this.isPlaying || this.isMuted) return;
                switch(type) {
                    case 'annihilation': this.playAnnihilation(); this.reactionCooldown = 30; break;
                    case 'fission':      this.playFission();      this.reactionCooldown = 20; break;
                    case 'fusion':       this.playFusion();        this.reactionCooldown = 20; break;
                    case 'birth':        this.playBirth();         this.reactionCooldown = 15; break;
                }
            },

            toggle() {
                if (!this.ctx) { this.start(); return; }
                this.isMuted = !this.isMuted;
                const t = this.ctx.currentTime;
                if (this.isMuted) {
                    this.masterGain.gain.linearRampToValueAtTime(0, t + 0.5);
                } else {
                    this.masterGain.gain.linearRampToValueAtTime(this.volume, t + 0.5);
                }
                const btn = document.getElementById('musicToggleBtn');
                if (btn) btn.style.borderColor = this.isMuted ? '#666' : '#b829dd';
                btn.textContent = this.isMuted ? 'üîá Muted' : 'üéµ Music';
            },

            start() {
                if (this.isPlaying) { this.toggle(); return; }
                this.init();
                this.isPlaying = true;
                this.isMuted = false;
                this.startAmbient();
                const btn = document.getElementById('musicToggleBtn');
                if (btn) { btn.textContent = 'üéµ On'; btn.style.borderColor = '#00ff88'; }
            },

            setVolume(val) {
                this.volume = val / 100;
                if (this.masterGain) this.masterGain.gain.setValueAtTime(this.volume, this.ctx.currentTime);
            }
        };

        function toggleSpaceMusic() { SpaceAudio.start(); }
        function setSpaceMusicVolume(v) { SpaceAudio.setVolume(parseInt(v)); }

        function toggleTrails() {
            showTrails = !showTrails;
            const btn = document.getElementById('trail-btn');
            if (btn) {
                btn.classList.toggle('active', showTrails);
                btn.textContent = showTrails ? '‚ú® Trails' : '‚Äî Trails';
            }
            if (!showTrails) trailLines.forEach(tl => { tl.line.visible = false; });
        }

        // Patch handleCollision to emit sounds
        const _origHandleCollision = handleCollision;
        window.handleCollision = function(p1, p2, i, j, toRemove, toAdd) {
            const prevLen = toRemove.length;
            _origHandleCollision(p1, p2, i, j, toRemove, toAdd);
            if (toRemove.length > prevLen) {
                // A reaction happened
                if (p1.type === 'antimatter' || p2.type === 'antimatter') {
                    SpaceAudio.onReaction('annihilation');
                } else if (p1.type === 'uranium' || p2.type === 'uranium') {
                    SpaceAudio.onReaction('fission');
                } else if (p1.type === 'plasma' && p2.type === 'plasma') {
                    SpaceAudio.onReaction('fusion');
                } else if (p1.type === 'life' || p2.type === 'life') {
                    SpaceAudio.onReaction('birth');
                }
            }
        };

        // Keyboard controls
        let keyHelpVisible = false;
        document.addEventListener('keydown', (e) => {
            const tag = e.target.tagName;
            if (tag === 'INPUT' || tag === 'SELECT') return;
            switch(e.key) {
                case ' ':
                    e.preventDefault();
                    document.getElementById('play-btn').click();
                    break;
                case 'r': case 'R':
                    reset();
                    break;
                case 'c': case 'C':
                    clearAll();
                    break;
                case 'm': case 'M':
                    toggleSpaceMusic();
                    break;
                case '1': loadPreset('bigbang'); break;
                case '2': loadPreset('solarsystem'); break;
                case '3': loadPreset('chemistry'); break;
                case '4': loadPreset('life'); break;
                case '5': loadPreset('plasma'); break;
                case '6': loadPreset('crystal'); break;
                case '7': loadPreset('magnetic'); break;
                case '8': loadPreset('reactor'); break;
                case '9': loadPreset('fusion'); break;
                case 'h': case 'H': spawnBatch('hydrogen', 30); break;
                case 'o': case 'O': spawnBatch('oxygen', 20); break;
                case 'n': case 'N': spawnBatch('neutron', 20); break;
                case 'f': case 'F': spawnBatch('photon', 20); break;
                case 't': case 'T': toggleTrails(); break;
                case '?':
                case 'Escape':
                    keyHelpVisible = !keyHelpVisible;
                    document.getElementById('keyHelp').style.display = keyHelpVisible ? 'block' : 'none';
                    break;
            }
        });

        // Start
        init();
    </script>
</body>
</html>